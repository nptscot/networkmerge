---
title: "Route network simplification for transport planning"
bibliography: references.bib
author:
  - name: Will Deakin
    affiliation: Digital, Data and Technology services, Network Rail, UK
    orcid: 0009-0008-5656-4469
  - name: Zhao Wang
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0002-4054-0533
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536
format:
  # pdf: default
  html: default
number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor: 
  markdown: 
    wrap: sentence
# # Uncomment to run with Jupyter:
# jupyter: python3
---

```{r}
# Engine: knitr
```

<!-- # Reproducibility {.unnumbered} -->

<!-- <details>

```{r}
#| name: r-setup
#| include: false
library(sf)
library(tmap)
library(dplyr)
library(ggplot2)
library(stplanr)

tmap_mode("plot")

rnet_x = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_x_ed.geojson")
rnet_y = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson")
```

To contribute to the papers written as quarto documents (with `.qmd` extensions) like this one, we recommend using the Quarto extension for VS Code.
You can go into the visual editor with the following shortcut:

```         
Ctrl+Shift+F4
```

You can then add citations with Ctrl+Shift+F11 and benefit from Quarto's other features for academic writing.

</details> -->

# Abstract {.unnumbered}

Route network datasets are central to transport models as key inputs and outputs.
The complexity of route network inputs from sources such as OpenStreetMap [@openstreetmap] has increased over time, enabling more precise modelling of sustainable modes such as walking and cycling.
However, this complexity can affect the visualisation of model results.
A common issue is the presence of multiple parallel ways on the same corridor, which can lead to visual artefacts and misinterpretation of model outputs.
To address these challenges, we present and compare two methods for *simplifying* route network datasets: 1) image skeletonization and 2) Voronoi diagram-centreline identification.
These methods have real-world applications, as illustrated in the "Simplified network" layer in the Transport for Scotland funded Network Planning Tool, which is publicly available at [www.npt.scot](https://www.npt.scot).
Based on open access data and the open source `parenx` Python package, available on the Python Package Index, these methods are not only reproducible but also adaptable, enabling their use in new contexts.

# Introduction

```{=html}
<!-- A wide range of data types can be used as inputs and outputs transport models, including route network datasets, origin-destination data, movement patterns captured by global positioning systems (GPS), and information on surface characteristics derived from remote sensing imagery.[^1]
Of these, route network datasets are unusual because they are commonly used as both inputs and outputs of transport models.

[^1]: See the [online documentation](https://transportgeography.org/contents/methods/network-data-models/).

As highlighted in the field of transport geography, network data models serve as digital representations of transportation networks, crucial for planning and operational purposes.
These models, enriched through graph theory, enclosed the complex, multi-modal nature of transportation data across various jurisdictions.
This complexity is particularly relevant when considering the enhancement of route network datasets for different use cases, offering widely applicable benefits.

This raises questions about what transport network datasets are, and how they can be optimized for more effective decision-making.
An intuitive definition is that route network datasets are digital representations of footpaths, cycleways, highways and other *ways* (to use the OpenStreetMap terminology) along which people and goods can travel. -->
```

Datasets representing route networks are important in every stage of transport planning.
Transport network datasets are *spatial networks* composed of nodes and edges, in which each edge has an associated edge cost (its weighted or unweighted length) [@barthélemy2011].
Nodes (points connecting edges) and the edges that connect them (lines between nodes representing ways) are located in space, with the edges representing the physical infrastructure of the transport network, often with attributes such as the type of way, its physical characteristics, and usage data, e.g. daily traffic for each way.
Route network simplification can be applied to both the input and output networks of transport models, with the aim of reducing complexity while preserving the spatial structure of the network and relevant attributes.

<!--
File formats for representing route networks include Transportation Network Test Problem files (TNTP and stored as a series of `.tntp` plain text files, examples of which can be found in [github.com/bstabler/TransportationNetworks](https://github.com/bstabler/TransportationNetworks)), `.DAT` files used by the proprietary SATURN transport modelling system and XML-based `.osm` or `.pbf` files that encode OpenStreetMap data.
Geographic file formats implementing the 'Simple Features Access' standard developed by the Open Geospatial Consortium ([OGC](https://www.ogc.org/standard/sfa/)), such as `.shp` and `.geojson`, can also be used to represent route networks.
-->

Growing availability of high resolution geographic datasets and performant hardware and software has enabled people (e.g. via OpenStreetMap) and mapping agencies to generate increasingly detailed maps, a trend that is set to continue.
Sustainable transport planning benefits from this trend, but the complexity and intricacy of street network geometries can create problems.
A clear and intuitive visual representation is crucial for identifying issues such as bottlenecks, congestion hotspots, and areas of poor accessibility.
Consequently, the necessity for network simplification becomes evident, aligning with wider 'map generalization' methods for pre-processing datasets depending on the scale of analysis [@sutton1998].
25 years since Sutton's paper on the topic, simplification of networks for transport planning and other applications remains an unsolved challenge. -->

Vector geometry simplification methods include Douglas-Peucker and Visvalingam-Whyatt algorithms [@liu2020vector; @de2014efficient].
While preserving the overall shape and geographical accuracy, this method struggles to reduce network complexity.
Vector smoothing approaches, including the use of Bezier curves [@pradhan2023modified] and Kernel-based smoothing [@duong2022statistical], can create more visually appealing lines or polygons, but do not reduce the number of vertices.

A common approach is simplification through conversion to an intermediate polygon (buffer) layer.
Numerous algorithms for such 'medial axis' calculations have been published in open source software repositories [e.g. @smogavec2012; @centerli2023].
Recent implementations of network simplification methods include the under-development `neatnet` Python package [@fleischmann2024], and the `parenx` package which is available on the Python Package Index [@deakin2024].
The latter is used in this paper.

Other network simplification methods for transport planning include automatic detection of 'face artifacts' [@fleischmann] and removal of 'slivers' to generate simplified representations of 'street blocks' [@grippa2018].
However, these methods tend to be 'all or nothing' and do not provide flexibility in terms of the level of simplification or which features are removed.

While the focus of this paper is on route network simplification for transport planning, it is worth noting that the general approach can be applied to other types of linear features.
Riverine research and flood mapping applications, for example, require estimates of many river characteristics, including simplified centerlines derived from datasets representing river banks, as implemented in software including the R package `cmgo` [@golly2017] and an approach implemented in Google Earth Engine called RivWidthCloud [@yang2020].
The `riverdist` R package, to provide another example, provides functionality for checking whether datasets representing river channels are braided and for removing braids by returning only the shortest paths along the lengths of river centerlines, for example [@tyers2016].

This approach was taken as we could only find a few examples for the aggregation and simplification of linear features, especially with transport and planning networks. However, as this general approach is based on the application of techniques used for image simplification, it can be applied to any overlapping linear features where aggregation is appropriate. For example, simplification of transport or other flow networks to produce an aggregated route-view as the basis for capacity analysis. Whether that is for active-transport, rail, road or other logical network flows.

```{=html}
<!-- Flexibility is important due to the wide range of transport planning use cases.
Some transport planning use cases require zoomed-in, geographically accurate and complex representations of transport networks, e.g. maps for junction design may have scales of 1:1000.
Other use cases, such as strategic network planning tools and 'planning support systems' [@page2020], typically involve zoomed-out representations of street networks at scales of 1:10,000+ beyond which dual carriageways are not relevant and can distort visualisation of networks. -->
```

The aim of this paper is to articulate the problem of complex route networks, present solutions with implementations in open source software for reproducible research, and describe applications of the methods to support more effective transport planning.
@sec-problem outlines the problem of complex route networks.
@sec-methods presents methods for route network simplification alongside results based on the example datasets.
@sec-application demonstrates the methods applied to a real transport network (Edinburgh, Scotland) and @sec-discussion concludes with a discussion of the results and future work.

# Problem definition {#sec-problem}

The problem tackled in this paper is the simplification of complex route networks.
This can be illustrated with reference to the Propensity to Cycle Tool for England (PCT) [@lovelace2017], the route networks of which are based on methods for aggregating multiple overlapping routes into a route network with non-overlapping linestrings [@morgan2020].
Implemented in the function `overline()` in the `stplanr` R package [@lovelace2017], the methods enable visualization of large transport networks and inform investment decisions in transport planning internationally [@lovelace2024; @félix2025].
However, this 'overline' approach, without further processing, has limitations:

-   Functionally redundant vertices are kept, leading to large file sizes and slow rendering.
-   Parallel ways that are not merged.

The latter issue is particularly problematic for visualisation of transport networks, as shown in @fig-pct [@lovelace2017].
The left panel shows Otley Road with a flow value of 818 (@fig-otley-road).
The right panel, by contrast, shows three parallel ways parallel to Armley Road with flow values of 515 (shown), 288 and 47 (values not shown) (@fig-armley-road).
Although this section of Armley road has a higher cycling potential than the section of Otley Road shown (515 + 288 + 47 > 818), this is not clear from the visualisation.

<!-- Clarification added: bullets describe *current approach limitations*, while the broader *problem* adds need for scalable, interpretable geometry for model communication and integration. -->

We therefore distinguish between (i) limitations of current aggregation methods (listed above) and (ii) the broader problem, which we define as: producing a geometrically concise, visually interpretable network that (a) preserves essential connectivity, (b) reduces redundant or parallel representations, (c) remains computationally tractable for large extents, and (d) can accept re-attachment of attribute data after simplification. A further nuance is that different user groups (planners, modellers, public audiences) require *graduated* levels of simplification rather than a single optimal output. <!-- TODO: Decide if a short before/after inset figure should be inserted here to visually anchor the definition. -->

# Data and Methods {#sec-methods}

```{r}
rnet_otley = sf::read_sf("./data/rnet_otley.geojson")
rnet_armley = sf::read_sf("./data/rnet_armley.geojson")
```

In this paper we use the two street networks discussed in the previous section to illustrate the methods.
See the ['`parenex` cookbook'](https://nptscot.github.io/networkmerge/cookbook.html) and [Methods](https://nptscot.github.io/networkmerge/methods.html) appendices for further details on the methods used in this paper and their application to alternative (railway based) datasets.

```{r}
#| include: false
#| label: tbl-input-data
input_data = tibble::tribble(
  ~Network, ~`N. segments`, ~Description, ~Source,
  "Otley Road", nrow(rnet_otley), "A corridor in Leeds represented by a single centreline", "Propensity to Cycle Tool (derived from OSM)",
  "Armley Road", nrow(rnet_armley), "A road in Leeds represented by multiple parallel 'braided' linestrings", "Propensity to Cycle Tool (derived from OSM)"
  )
knitr::kable(input_data)
```

There are two main challenges that need to be overcome to simplify transport networks, in a way that preserves their value:

1.  Simplifying the *geometry*
2.  Assigning attributes to the simplified network

The key contributions of the paper are the novel methods of image skeletonization, presented in @sec-simplification-via-skeletonization, and simplification with Voronoi diagrams to identify central lines, covered in @sec-simplification-via-voronoi-polygons.
<!-- To make use of simplified networks in transport planning, it is also necessary to assign attributes to the simplified network.
This is covered in @sec-joining-route-networks. -->

```{=html}
<!-- TODO: shouldn't the following topics be stand-alone subsections rather than existing within the skeletonization section?
Additionally, the section tackles challenges associated with knots at intersections, offering solutions for their removal to simplify the network's appearance.
The concept of a primal network that represents a high level of simplification is explored as well. -->
```

<!-- ## Topology-preserving simplification {#sec-topology-preserving-simplification}

Topology-preserving simplification reduces the number of vertices in a linestring while preserving (or at least attempting to preserve) the topology of the network, i.e. not merging parallel lines. -->

## Simplification via skeletonization {#sec-simplification-via-skeletonization}

The skeletonization approach generates a simplified network by buffering the network, applying an image skeletonization algorithm, and extracting line segments from a raster of this buffer.

<!--- ### Create a projected combined buffered geometry --->

In both the skeletonization and Voronoi approaches, the network simplification process starts by applying a buffer to linear geometry in a projected, rather than coordinate system.
<!-- , achieved using the `get_geometry_buffer` function. -->
We use a buffer size of 8 m in this paper. This value is informed by typical widths of a UK two-lane highway with an example for a typical 2-way road being specified in the [Design Manual for Roads and Bridges (DMRB)](https://assets.publishing.service.gov.uk/media/5a7e0035ed915d74e6223743/pdfmanforstreets.pdf#page=81) as "min 4.8 m, max 8.8 m" and the minimum GB rail centre-line track separation of 3.26m, and two sections of 1.435m standard gauge.
This parameter can be adjusted to suit the use case and local contexts, using the `buffer` parameter of the simplification functions.

```{python}
#| name: python-setup-packages
#| include: false
import warnings
from functools import partial
from pathlib import Path

import geopandas as gp
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from parenx.shared import combine_line, get_geometry_buffer, get_primal, get_source_target
from parenx.skeletonize import (
    get_affine_transform,
    get_raster_line,
    get_skeleton,
    split_centres,
)
from parenx.voronoi import (
    filter_buffer,
    filter_distance,
    get_linestring,
    get_geometry_line,
    get_voronoi_line,
    get_voronoi,
    get_segment_nx,
    set_geometry,
)
from shapely import box, get_coordinates, set_precision, unary_union
from shapely.affinity import affine_transform
from shapely.geometry import MultiPoint, Point
from shapely.ops import voronoi_diagram
```

```{python}
#| include: false
plt.rcParams["figure.figsize"] = (12, 12)

CRS = "EPSG:27700"
buffer_size = 8.0
radius = buffer_size
set_precision_pointone = partial(set_precision, grid_size=0.1)

base_otley = gp.read_file("./data/rnet_otley.geojson").to_crs(CRS)
base_otley["geometry"] = base_otley["geometry"].map(set_precision_pointone)
base_otley = combine_line(base_otley["geometry"]).to_frame("geometry")
otley_geometry = get_geometry_buffer(base_otley["geometry"], radius=buffer_size)

# Same for Armley:

base_armley = gp.read_file("./data/rnet_armley.geojson").to_crs(CRS)
base_armley["geometry"] = base_armley["geometry"].map(set_precision_pointone)
base_armley = combine_line(base_armley["geometry"]).to_frame("geometry")
armley_geometry = get_geometry_buffer(base_armley["geometry"], radius=buffer_size)
```

<!-- ### Network skeletonization -->

In skeletonization, overlapping lines are identified, buffered, transformed into a raster image, the image processed through a thinning algorithm, and a skeletal representation of the original network produced (see [Methods](https://nptscot.github.io/networkmerge/methods.html) appendix for details).
This skeletal structure preserves the overall extent and connectivity of the network, with a central line that follows the centre-line of the combined buffered area.

In detail, skeletonization is only applied where more than line-segment buffer overlaps.
To identify overlapping line-segments, the buffer is split at the end of each line-segment.
The overlapping line-segments are then buffered while retaining the remaining disjoint lines.

```{=html}
<!---This visualization demonstrates the process of cutting and segmenting the buffer geometries. It highlights the transformations from the initial buffered geometries to a more segmented and manageable form, preparing them for further analysis and simplification steps​.
It effectively highlights the contrast between the more intricate and the simpler sections within these networks. --->
```

<!-- ::: {#fig-split-ends layout-ncol="2"} -->
```{python}
split_centre = partial(split_centres, offset=np.sqrt(1.5) * radius)

## overlapping
otley_centre = gp.GeoSeries(base_otley["geometry"].map(split_centre), crs=CRS)
otley_centre = otley_centre.buffer(radius, 0, join_style="round", cap_style="round")
combined_otley = gp.GeoSeries(unary_union(otley_centre.values).geoms, crs=CRS)
# combined_otley.plot()
```

```{python}
## overlapping
armley_centre = gp.GeoSeries(base_armley["geometry"].map(split_centre), crs=CRS)
armley_centre = armley_centre.buffer(radius, 0, join_style="round", cap_style="round")
combined_armley = gp.GeoSeries(unary_union(armley_centre.values).geoms, crs=CRS)
# combined_armley.plot()
```

```{=html}
<!--- Truncated and segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks.
::: --->
```

```{python}
i, j = base_otley.sindex.query(combined_otley, predicate="intersects")

base_otley["class"] = -1
base_otley.loc[j, "class"] = combined_otley.index[i]
count = base_otley.groupby("class").count()
base_otley = base_otley.join(count["geometry"].rename("count"), on="class")
ix = base_otley["class"] == -1
base_otley.loc[ix, "count"] = 0

i, j = base_armley.sindex.query(combined_armley, predicate="intersects")

base_armley["class"] = -1
base_armley.loc[j, "class"] = combined_armley.index[i]
count = base_armley.groupby("class").count()
base_armley = base_armley.join(count["geometry"].rename("count"), on="class")
ix = base_armley["class"] == -1
base_armley.loc[ix, "count"] = 0
```

```{python}
ix = base_otley["count"].isin([0, 1])
p = base_otley.loc[~ix, "geometry"].copy()
p = p.buffer(radius, 512, join_style="round", cap_style="round")
try:
    p = gp.GeoSeries(list(unary_union(p.values).geoms), crs=CRS)
except AttributeError:
    p = gp.GeoSeries(unary_union(p.values), crs=CRS)

q = base_otley.loc[ix, "geometry"].buffer(0.612, 64, join_style="mitre", cap_style="round")
otley_segment = pd.concat([p, q])
try:
    otley_segment = gp.GeoSeries(list(unary_union(otley_segment.values).geoms), crs=CRS)
except AttributeError:
    otley_segment = gp.GeoSeries(unary_union(otley_segment.values), crs=CRS)
# otley_segment.plot()
```

```{python}
#| include: false
ix = base_armley["count"].isin([0, 1])
p = base_armley.loc[~ix, "geometry"].copy()
p = p.buffer(radius, 512, join_style="round", cap_style="round")
try:
    p = gp.GeoSeries(list(unary_union(p.values).geoms), crs=CRS)
except AttributeError:
    p = gp.GeoSeries(unary_union(p.values), crs=CRS)

q = base_armley.loc[ix, "geometry"].buffer(0.612, 64, join_style="mitre", cap_style="round")
armley_segment = pd.concat([p, q])
try:
    armley_segment = gp.GeoSeries(list(unary_union(armley_geometry.values).geoms), crs=CRS)
except AttributeError:
    armley_segment = gp.GeoSeries(unary_union(armley_segment.values), crs=CRS)
# armley_segment.plot()
```

<!-- Segmented line-buffer geometries (top) and geometries to be skeletonized (bottom) for the Otley Road (left) and Armley Road (right) networks. -->
<!-- ::: -->

As detail is lost in transforming of the geometry to an image buffer or raster, more detail can be retained by using an affine transformation to increase the number of points in the buffer prior to skeletonization and reducing scale when creating the simplified linear geometric representation.
This scale operation is a uniform affine scale transformation applied to increase the detail contained in the raster image. An increase in scale reduces undulation but at the cost of longer processing time and increased memory, which varies as the square of scale value. This transformation is scaled to ensure that the projected coordinate geometry of the network aligns accurately with the corresponding dimensions of the scaled raster image.

The raster image also requires pre-processing to eliminate small holes that appear where buffered lines run parallel or intersect at shallow angles.
The skeletonization algorithm is then applied to the raster image yielding a skeletal raster image and converted back into a linear vector geometry, completing the vector-to-raster-to-vector geometry transformation (see [Methods](https://nptscot.github.io/networkmerge/methods.html) appendix for details).

```{python}
import rasterio.features as rif

r_matrix_otley, s_matrix_otley, out_shape_otley = get_affine_transform(otley_geometry, scale=2.0)
# For Armle
r_matrix_armley, s_matrix_armley, out_shape_armley = get_affine_transform(armley_geometry, scale=2.0)
```


```{python}
from skimage.morphology import remove_small_holes, skeletonize
import rasterio.plot as rip
```

<!-- ::: {#fig-rasterize layout-ncol="2"}
```{python}
otley_im = rif.rasterize(otley_segment.values, transform=r_matrix_otley, out_shape=out_shape_otley)
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    otley_im = remove_small_holes(otley_im, 20).astype(np.uint8)
import rasterio.plot as rip
rip.show(otley_im, cmap="Greys", title="Otley buffer geometry")
```

```{python}
armley_im = rif.rasterize(armley_segment.values, transform=r_matrix_armley, out_shape=out_shape_otley)
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    armley_im = remove_small_holes(armley_im, 20).astype(np.uint8)
rip.show(armley_im, cmap="Greys", title="Armley buffer geometry")
```

Rasterized versions of the Otley Road (left) and Armley Road (right) networks, with post processing to remove small holes.
::: -->

<!-- Restore thin skeleton figure -->
::: {#fig-thin-skeleton layout-ncol="2"}
```{python}
otley_skeleton = skeletonize(otley_im).astype(np.uint8)
rip.show(otley_skeleton, cmap="Greys", title="Otley skeleton raster")
otley_p = np.stack(np.where(otley_skeleton >= 1))
otley_point = gp.GeoSeries(map(Point, otley_p.T), crs=CRS)
```

```{python}
armley_skeleton = skeletonize(armley_im).astype(np.uint8)
rip.show(armley_skeleton, cmap="Greys", title="Armley skeleton raster")
armley_p = np.stack(np.where(armley_skeleton >= 1))
armley_point = gp.GeoSeries(map(Point, armley_p.T), crs=CRS)
```
Skeletonized raster images for Otley (left) and Armley (right).
:::

<!-- Restore skeleton vector figure -->
::: {#fig-skeleton-vector layout-ncol="2"}
```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_otley)
otley_transform = otley_point.map(shapely_transform).map(set_precision_pointone)
otley_transform.plot(edgecolor="black", color="blue")
```

```{python}
armley_transform = armley_point.map(shapely_transform).map(set_precision_pointone)
armley_transform.plot(edgecolor="black", color="blue")
```
Skeletonized point geometries transformed back to projected space (Otley left, Armley right).
:::

<!-- Restore skeleton line figure -->
::: {#fig-skeleton-line layout-ncol="2"}
```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_otley)
otley_sk = otley_line.map(shapely_transform).map(set_precision_pointone)
otley_sk = otley_sk.set_crs(CRS)
otley_sk.plot()
```

```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_armley)
armley_sk = armley_line.map(shapely_transform).map(set_precision_pointone)
armley_sk = armley_sk.set_crs(CRS)
armley_sk.plot()
```
Simplified line geometries derived from skeletonization (Otley left, Armley right).
:::

## Simplification via Voronoi polygons {#sec-simplification-via-voronoi-polygons}

Voronoi simplification takes the buffered network segments and converts them into a set of points.
The edges of these buffers are then segmented into sequences of points.
From these sequences, a centre-line is derived based on a set of Voronoi polygons that cover these points.
For more detail on segmentation and Voronoi simplification see the [Appendix](https://nptscot.github.io/networkmerge/methods.html#sec-simplification-via-voronoi-polygons).
This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.


```{python}
scale = 10.0
tolerance = 0.1

otley_clip = box(426800, 437400, 427000, 437600)
armley_clip = box(427200, 433500, 427400, 433700)
```

<!-- ::: {#fig-boundary layout-ncol="2"} -->
```{python}
otley_boundary = get_geometry_line(otley_geometry)
# otley_boundary.plot()
```

```{python}
armley_boundary = get_geometry_line(armley_geometry)
# armley_boundary.plot()
```

<!-- Simplified boundaries of the Otley Road (left) and Armley Road (right) networks. -->
<!-- ::: -->

<!-- @fig-segment showcase the conversion of segmented LineString geometries into point geometries. -->
<!-- This essential transformation forms the basis for constructing Voronoi diagrams. -->

<!-- ::: {#fig-segment layout-ncol="2"} -->
```{python}
otley_segment = get_segment_nx(otley_boundary, scale).reset_index(drop=True)
# ax = otley_segment.clip(otley_clip).plot(edgecolor="red", linestyle='--', linewidth=1)
# ax.xaxis.set_ticklabels([])
# ax.yaxis.set_ticklabels([])
```

```{python}
armley_segment = get_segment_nx(armley_boundary, scale).reset_index(drop=True)
# ax = armley_segment.clip(armley_clip).plot(edgecolor="red", linestyle='--', linewidth=1)
# ax.xaxis.set_ticklabels([])
# ax.yaxis.set_ticklabels([])
```

<!-- Detail segmented boundaries of the Otley Road (left) and Armley Road (right) networks. -->
<!-- ::: -->

<!-- @fig-voronoi-point, the process of converting the segmented LineString geometries into point geometries is illustrated. -->
<!-- This transformation is essential for the creation of Voronoi diagrams. -->

<!-- ::: {#fig-voronoi-point layout-ncol="2"} -->
```{python}
otley_point = otley_segment.loc[:, "geometry"].map(get_coordinates).explode()
otley_point = MultiPoint(otley_point[::2].map(Point).values)
GP_otley_points = gp.GeoSeries(otley_point, crs=CRS)
GP_otley_points.plot(color="blue")
```

```{python}
armley_point = armley_segment.loc[:, "geometry"].map(get_coordinates).explode()
armley_point = MultiPoint(armley_point[::2].map(Point).values)
GP_armley_points = gp.GeoSeries(armley_point, crs=CRS)
GP_armley_points.plot(color="blue")
```
Voronoi seed points (Otley left, Armley right).
:::

<!-- Restore Voronoi diagrams figure -->
::: {#fig-voronoi layout-ncol="2"}
```{python}
otley_envelope = box(*otley_point.bounds)
otley_voronoi = voronoi_diagram(otley_point, envelope=otley_envelope, tolerance=tolerance, edges=True)
otley_voronoi = gp.GeoSeries(map(set_precision_pointone, otley_voronoi.geoms), crs=CRS)
otley_voronoi.plot()
```

```{python}
armley_envelope = box(*armley_point.bounds)
armley_voronoi = voronoi_diagram(armley_point, envelope=armley_envelope, tolerance=tolerance, edges=True)
armley_voronoi = gp.GeoSeries(map(set_precision_pointone, armley_voronoi.geoms), crs=CRS)
armley_voronoi.plot()
```
Raw Voronoi diagrams within bounding envelopes.
:::

<!-- Restore filtered Voronoi lines figure -->
::: {#fig-voronoi-2 layout-ncol="2"}
```{python}
otley_voronoi = otley_voronoi.explode(index_parts=False).clip(otley_envelope)
ix = ~otley_voronoi.is_empty & (otley_voronoi.type == "LineString")
otley_voronoi = otley_voronoi[ix].reset_index(drop=True)
otley_voronoi.plot()
```

```{python}
armley_voronoi = armley_voronoi.explode(index_parts=False).clip(armley_envelope)
ix = ~armley_voronoi.is_empty & (armley_voronoi.type == "LineString")
armley_voronoi = armley_voronoi[ix].reset_index(drop=True)
armley_voronoi.plot()
```
Filtered Voronoi linework (Otley left, Armley right).
:::

<!-- Restore Voronoi simplified selection figure -->
::: {#fig-voronoi-simplified layout-ncol="2"}
```{python}
otley_line = filter_distance(otley_voronoi, otley_boundary, offset)
otley_line.plot()
```

```{python}
armley_line = filter_distance(armley_voronoi, armley_boundary, offset)
armley_line.plot()
```
Voronoi lines retained inside buffered corridors (< 0.5 buffer width from edges).
:::

<!-- Restore primal skeleton and primal Voronoi figures -->
::: {#fig-primal-skeleton layout-ncol="2"}
```{python}
otley_edge_sk = get_primal(otley_sk)
otley_edge_sk.plot()
```
```{python}
armley_edge_sk = get_primal(armley_sk)
armley_edge_sk.plot()
```
Primal skeleton networks (Otley left, Armley right).
:::

::: {#fig-primal-voronoi layout-ncol="2"}
```{python}
otley_edge = get_primal(otley_line)
otley_edge.plot()
```
```{python}
armley_edge = get_primal(armley_line)
armley_edge.plot()
```
Primal Voronoi networks (Otley left, Armley right).
:::
