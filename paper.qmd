---
title: "Route network simplification for transport planning"
#  methods and applications"
# Alternatives:
# title: "Network simplification: application to the visualisation of transport networks"
# title: "methods and applications to support the visualisation, modelling and redesign of transport systems"
bibliography: references.bib
author: 
  - name: Robin Lovelace
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0001-5679-6536
  - name: Zhao Wang
    affiliation: Leeds Institute for Transport Studies, University of Leeds, UK
    orcid: 0000-0002-4054-0533
  - name: Will Deakin
    affiliation: Network Rail, UK
    orcid: 0009-0008-5656-4469
  - name: Josiah Parry
    affiliation: Environmental Systems Research Institute, Redlands, CA, USA 
    orcid: 0000-0001-9910-865X
format:
  # pdf: default
  html: default
number-sections: true
execute: 
  echo: false
  message: false
  warning: false
editor: 
  markdown: 
    wrap: sentence
# # Uncomment to run with Jupyter:
# jupyter: python3
---

```{=html}
<!-- Blurb form special issue in Journal of Physics: Complexity


Journal of Physics: Complexity
Focus Issue on Urban Mobility and Green Transportation in Sustainable Cities
Guest Editors

    Ruiqi Li, Beijing University of Chemical Technology, China
    Marta C. Gonzalez, University of California, USA
    Michael Szell, IT University of Copenhagen, Denmark
    Luis E. Olmos, University of Medellin, Colombia 

Scope

Along with the rapid urbanization and car-oriented transportation systems for most cities worldwide, challenges associated with urban mobility and transportation have escalated, calling for greener and more sustainable solutions to address environmental, social, and economic concerns. For example, the flooding of car and conventional transportation system are responsible for a variety of urban illnesses, including traffic congestion, air pollution, energy deficiency, greenhouse gas emissions, loss of home value and property taxes, and deterioration of health of residents, and underscoring the urgent need for a paradigm shift towards green and sustainable alternatives.

This Focus aims to explore the intersection of physics and complexity in the context of urban mobility and green transportation, shedding light on cutting-edge research that not only elucidates the fundamental principles governing these systems but also offers practical applications to create more sustainable and efficient cities. Regarding the green transportation, it can be any means of travel that does not negatively impact the environment, including (but are not limited to) bikes (dockless or docked sharing ones), ebikes (both private or sharing ones), electric vehicles. A better green transportation would involve both the infrastructure level and human behaviors level.

The focus issue is concerned with all aspects of urban mobility and green transportation, topics addressed include, but are not limited to:

    Empirical and theoretical study of human mobility in green transportation
    Design and/or optimization of sidewalk, bicycle, or micromobility networks in cities
    Road safety in green transportation system
    Infrastructure analysis of green transportation system
    Design and/or optimization of charging stations in cities
    The relationship between urban form and vehicle kilometers traveled (VKT) and reduction of emissions
    Rebalancing strategy for dockless/docked bike-sharing systems
    Empirical and theoretical study of mobility patterns of sharing conveyances (e.g., dockless sharing bikes or sharing cars)
    Analysis and/or optimization of ride sharing of car-pooling platforms
    Agent-based modeling and simulation for urban mobility in green transportation
    Implications for policymaking and urban designers
    Measuring complexity of urban mobility
    Green mobility and social distancing in times of pandemic -->
```

------------------------------------------------------------------------

# Reproducibility {.unnumbered}

<details>

To reproduce this paper you need `quarto` installed.

After installing the dependencies, you can reproduce the paper by running the following command in the terminal:

``` bash
quarto render paper.qmd
```

Install the dependencies by cloning the repository and running the following:

``` r
requirements_txt = readLines("requirements.txt")
py_install(requirements_txt, pip = TRUE)
```

```{r}
#| name: python-setup
#| include: false
requirements_txt = readLines("requirements.txt")
# Check if Python is installed:
if (!requireNamespace("reticulate")) {
  install.packages("reticulate")
}
reticulate::install_python()
# Install Python dependencies with reticulate:
reticulate::py_install(requirements_txt, pip = TRUE)
```

```{r}
#| name: r-setup
library(sf)
library(tmap)
library(dplyr)
library(ggplot2)
library(stplanr)

tmap_mode("plot")

rnet_x = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_x_ed.geojson")
rnet_y = sf::read_sf("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson")
```

To contribute to the papers written as quarto documents (with `.qmd` extensions) like this one, we recommend using the Quarto extension for VS Code.
You can go into the visual editor with the following shortcut:

```         
Ctrl+Shift+F4
```

You can then add citations with Ctrl+Shift+F11 and benefit from Quarto's other features for academic writing.

</details>

# Abstract {.unnumbered}

Route network datasets are central to transport models as key inputs and outputs.
The complexity of route network inputs from sources such as OpenStreetMap has increased over time, enabling more precise modelling of sustainable modes such as walking and cycling.
However, this complexity can affect the visualisation of model results.
A common issue is the presence of multiple parallel ways on the same corridor.
This can lead to incorrect traffic flow values inferred from visual inspection of results, misinterpretation of model outputs and, potentially, investment in the wrong places.
To address this challenges, we present and compare two methods for *simplifying* route network datasets: 1) image skeletonization and 2) Voronoi diagram-centreline identification approaches.
These methods have real-world applications in urban mobility and green transportation, as illustrated by the use of the simplified network results in the Transport for Scotland funded Network Planning Tool, which is publicly available at [www.nptscot.scot](https://www.nptscot.scot).
Being developed with open data and open-source software, these methods are not only reproducible but also adaptable, enbabling their use in new contexts.

# Introduction

Datasets representing route networks are important in every stage of modern data-driven transport planning.
A wide range of data types can be used as inputs and outputs transport models, including route network datasets, origin-destination data, movement patterns captured by global positioning systems (GPS), and information on surface characteristics derived from remote sensing imagery.[^1]
Of these, route network datasets are unusual because they are commonly used as both inputs and outputs of transport models.
Methods to modify and potentially enhance route network datasets, for different use cases, could therefore have widely applicable benefits.

[^1]: See the [online documentation](https://sumo.dlr.de/docs/Simulation/Output/index.html) of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.

This raises questions about what transport network datasets are, and how they can be optimized for more effective decision-making.
An intuitive definition is that route network datasets are digital representations of footpaths, cycleways, highways and other *ways* (to use the OpenStreetMap terminology) along which people and goods can travel.
More formally, transport network datasets are *spatial networks* "for which the nodes are located in a space equipped with a metric", space typically being two-dimensional space and the main metric being Euclidean (or weighted Euclidean) distances [@barthélemy2011].
Transport networks must contain spatial information on the coordinates of vertices (points along ways) and edges that connect them (the straight lines between vertices representing ways).
Transport networks can also contain 'attribute data' such as the type of way (e.g. road, rail, cycle), its physical characteristics (e.g. is lit at night), and usage data, e.g. the amount of daily traffic using each segment.
As inputs, route networks typically represent road or other transport networks along which vehicles travel.
When generated as model outputs, they are typically used to visualize metrics such as flow over different time periods on transport networks at the segment level [@sutton1998].

File formats for representing route networks include Transportation Network Test Problem files (TNTP and stored as a series of `.tntp` plain text files, examples of which can be found in [github.com/bstabler/TransportationNetworks](https://github.com/bstabler/TransportationNetworks)), `.DAT` files used by the proprietary SATURN transport modelling system and XML-based `.osm` or `.pbf` files that encode OpenStreetMap data.
A more recent approach is to represent transport networks in standard geographic file formats.
In this approach, used in the present paper, transport networks are represented as a series of non-overlapping linestrings, with attributes such as way type and flow.
Making transport datasets compliant with the 'simple features' geographic data specification in this way has advantages, <!-- compared with the proliferation of formats used by proprietary software, --> enabling more easier sharing of datasets between people and programs.
The simple features standard is formalised by the International Organization for Standardization in [ISO 19125-1:2004](https://www.iso.org/standard/40114.html) and implemented in a wide range of file formats such as ESRIs shapefile, GeoJSON, and the open standard for geographic data, GeoPackage.
For ease of data sharing, we share transport networks used in this paper as plain text GeoJSON files.

A problem associated with the trend towards geographic representation of route networks is increasing file sizes and complexity.
With the increasing availability of high resolution imagery, citizens (e.g. via OpenStreetMap) and national mapping agencies are mapping more and more detail.
Overall this is a good thing for transport planning research, but excess complexity and intricacy can lead to problems, as outlined in the next section.
The problem of network simplification is not new.
It can be seen as one approach to solving a broader issue of 'map generalization' that allows "different representations of the spatial features" of transport network datasets (or any geographic dataset) depending on the scale of analysis [@sutton1998].
For example, strategic network planning tools (which are the use case motivating the methods presented in this paper) — which will typically involve maps with a scale of 1:10,000+ — do not need to show the same level of detail as a junction design tool that is based on more zoomed-in representations of transport networks, e.g. less than 1:2000.

The aim of this paper is to articulate the problem of complex route networks, present solutions with implementations in open source software for reproducible research, and describe applications of the methods to support more effective transport planning.
@sec-problem outlines the problem of complex route networks.
@sec-data describes the input datasets.
@sec-methods presents methods for route network simplification alongside results based on the example datasets.
In @sec-discussion we discuss the results and outline future work.

```{=html}
<!-- Much research has focussed on generating and modelling transport network datasets.
This is unsurprising given the importance of transport networks as inputs and outputs of transport models.
Much has been written about network 'cleaning' and simplification as a pre-processing step in transport modelling. -->
```
<!-- Todo: add papers on network cleaning and simplification. -->

<!-- However, there has been relatively little research into transport network visualisation, despite the importance of visualisation to enable more people to understand transport models, for informing policies and prioritising investment in transport planning. -->

# Prior work and problem definition {#sec-problem}

@morgan2020 presented methods for combining multiple overlapping routes into a single route network with non-overlapping linestrings for visualisation, implemented in the function `overline()`.
The approach takes overlapping linestrings representing multiple routes and combines them into a single network with non-overlapping linestrings.
The approach has been used to visualise large transport networks, informing investment decisions in transport planning internationally.
However, the 'overline' approach, without further processing, has limitations:

-   It does not remove redundant vertices, which can lead to large file sizes and slow rendering.
-   Parallel ways that are part of the same corridor are not merged into a single way, resulting in outputs that are difficult to interpret.

The final point is most relevant to the present paper.
An example of the issue is shown in @fig-pct from the Propensity to Cycle Tool for England (PCT), with segment values representing daily commuter cycling potential flows [@lovelace2017].
The left panel shows Otley Road with a flow value of 818 (@fig-otley-road).
The right panel, by contrast, shows three parallel ways parallel to Armley Road with flow values of 515 (shown), 288 and 47 (values not shown) (@fig-armley-road).
Although this section of Armley road has a higher cycling potential than the section of Otley Road shown (515 + 288 + 47 \> 818), this is not clear from the visualisation.

::: {#fig-pct layout-ncol="2"}
![](images/otley-road-narrow.png){#fig-otley-road}

![](images/armley-road-narrow.png){#fig-armley-road}

Illustration of issues associated with route network-level results containing multiple parallel ways on the same corridor: it is not clear from the visualisation that the corridor shown in the right hand figure has greater flow than the corridor shown in the left.
Source: open access Propensity to Cycle Tool results available at www.pct.bike.
:::

A subsequent step described in the paper is to post-process the geographic representation of the transport network into a raster image, which can be used to visualise the network.
The 'rasterisation' stage can tackle some of the issues associated with multiple parallel ways, but introduces new issues, as shown in @fig-rasterisation.

::: {#fig-rasterisation layout-ncol="2"}
![](images/otley-road-raster.png){#fig-otley-road-raster}

![](images/armley-road-raster.png){#fig-armley-road-raster}

Rasterised network results for the same corridors shown in @fig-pct.
Note the visual artefacts such as 'staircase' effects and overlapping values resulting from parallel lines along Armley Road (right panel).
Source: open access Propensity to Cycle Tool results available at www.pct.bike.
:::

The methods presented in this paper are designed to take a complex network as an input and output a simplified network, while preserving the spatial structure of the network and relevant attributes.
By reducing duplicated parallel lines and other intricacies, the outputs can enable easier-to-interpret visualisations of transport behaviour on the network patterns and behaviors.

# Data {#sec-data}

```{r}
rnet_otley = sf::read_sf("./data/rnet_otley.geojson")
rnet_armley = sf::read_sf("./data/rnet_armley.geojson")
```

```{r}
```

The input datasets are presented in @tbl-input-data.

::: {#tbl-input-data}
```{r}
#| label: tbl-input-data
input_data = tibble::tribble(
  ~Network, ~`N. segments`, ~Description, ~Source,
  "Otley Road", nrow(rnet_otley), "A corridor in Leeds represented by a single centreline", "Propensity to Cycle Tool (derived from OSM)",
  "Armley Road", nrow(rnet_armley), "A road in Leeds represented by multiple parallel 'braided' linestrings", "Propensity to Cycle Tool (derived from OSM)"
  )
knitr::kable(input_data)
```

Input datasets used in this paper.
:::

The input datasets are illustrated in @fig-input-data.

::: {#fig-input-data}
```{r}
tmap_mode("plot")
tmap_arrange(
  qtm(rnet_otley),
  qtm(rnet_armley)
)
```

Illustration of the size and level of spatial complexity of the input datasets.
:::

# Methods {#sec-methods}

There are two main challenges that need to be overcome to simplify transport networks, in a way that preserves their value:

1.  Simplifying the *geometry*
2.  Assigning attributes to the simplified network

## Simplifying the geometry

```{=html}
<!-- 

Two fundamental approaches to simplifying transport networks are:

-   Simplifying the geometry of the network, by removing redundant vertices and edges and/or by merging parallel ways and *then* merging the attributes of the original network onto the simplified network.
-   Iteratively removing edges and updating the attributes of the remaining edges by routing through the network.

In this paper we will focus on the former approach, which assumes that a simplified geographic representation of the network is available. -->
```
### Topology-preserving simplification

Topology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network.
As shown in top panel of @fig-topology-preserving, topology-preserving simplication *can* reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in @fig-topology-preserving.

::: {#fig-topology-preserving layout-ncol="1"}
```{r}
input = sf::read_sf('data/rnet_otley.geojson')
input_projected = sf::st_transform(input, "EPSG:27700")
simplification_levels = c(1, 0.5, 0.1, 0.001)
# ordered factor of simplification levels:
simplification_df = data.frame(
  id = as.character(1:length(simplification_levels)),
  simp_factor = simplification_levels,
  keep = paste0("Keep: ", round(as.numeric(simplification_levels) * 100, 2), "%")
  )
simplification_df$keep = ordered(simplification_df$keep, levels = simplification_df$keep)

smplfy = function(x_list, keep) {
  x_list = lapply(
    keep,
    function(x) {
      res = rmapshaper::ms_simplify(x_list, keep_shapes = TRUE, keep = x)
      res$id = x
      res
    }
    )
  do.call(rbind, x_list)
}
if (!file.exists("data/input_simplified_otley.geojson")) {
  input_simplified = smplfy(input_projected, simplification_levels)
  sf::write_sf(input_simplified, "data/input_simplified_otley.geojson", delete_dsn = TRUE)
} else {
  input_simplified = sf::read_sf('data/input_simplified_otley.geojson')
}

input_simplified = left_join(
  input_simplified,
  simplification_df,
  by = join_by(id == simp_factor)
  )
m_otley = tm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +
  tm_lines() +
  tm_facets(by = "keep", free.coords = TRUE) 

# Same for Armley:
input = sf::read_sf('data/rnet_armley.geojson')
input_projected = sf::st_transform(input, "EPSG:27700") 
if (!file.exists("data/input_simplified_armley.geojson")) {
  input_simplified = smplfy(input_projected, simplification_levels)
  sf::write_sf(input_simplified, "data/input_simplified_armley.geojson", delete_dsn = TRUE)
} else {
  input_simplified = sf::read_sf('data/input_simplified_armley.geojson')
}
input_simplified = left_join(
  input_simplified,
  simplification_df,
  by = join_by(id == simp_factor)
  )
m_armley = tm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +
  tm_lines() +
  tm_facets(by = "keep", free.coords = TRUE)
# m_otley
tmap_arrange(m_otley, m_armley)
```

Illustration of topology-preserving simplification, using the `mapshaper` JavaScript package.
The % values represent the "percentage of removable points to retain" argument values used in the simplification process.
:::

### Network Simplification

The paper presents two approaches for network simplification: one involves image skeletonization, while the other utilizes Voronoi diagrams to identify central lines.
The detailed steps of the methodology will be presented in the following sections.

### Create a projected combined buffered geometry:

In both approaches, the network simplification process initiates with the generation of buffered geometries, achieved using the get_geometry_buffer function.
A buffer size of 8 meters is selected for this purpose.
These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.

```{python}
#| name: python-setup-packages
from functools import partial
from shapely import box
from shapely.ops import voronoi_diagram, split
from shapely import box, line_interpolate_point, snap
from shapely.ops import voronoi_diagram
import geopandas as gp
import matplotlib.pyplot as plt
from shapely import get_coordinates, line_merge, set_precision, unary_union
from shapely.geometry import MultiPoint,MultiLineString,LineString,Point
import pandas as pd
import numpy as np
```

```{python}

plt.rcParams["figure.figsize"] = (12, 12)

def get_geometry_buffer(this_gf, radius=8.0):
    """get_geometry_buffer: return radius buffered GeoDataFrame
    args:
      this_gf: GeoDataFrame to
      radius: (default value = 8.0)

    returns:
      buffered GeoSeries geometry
    """
    r = gp.GeoSeries(this_gf, crs=CRS).buffer(radius, join_style="round", cap_style="round")
    union = unary_union(r)
    try:
        r = gp.GeoSeries(union.geoms, crs=CRS)
    except AttributeError:
        r = gp.GeoSeries(union, crs=CRS)
    return r

CRS = "EPSG:27700"
buffer_size = 8.0
radius = buffer_size

def get_split(line, point, separation=1.0e-6):
    return list(split(snap(line, point, separation), point).geoms)

def combine_line(line):
    """combine_line: return LineString GeoSeries combining lines with intersecting endpoints
    args:
      line: mixed LineString GeoSeries
    returns:
      join LineString GeoSeries
    """
    r = MultiLineString(line.values)
    return gp.GeoSeries(line_merge(r).geoms, crs=CRS)

EMPTY = LineString([])
def split_ends(line, offset):
    if line.length <= 2.0 * offset:
        return line, EMPTY, EMPTY
    p = line_interpolate_point(line, offset)
    head, centre = get_split(line, p)
    p = line_interpolate_point(centre, -offset)
    centre, tail = get_split(centre, p)
    return head, centre, tail

set_precision_pointone = partial(set_precision, grid_size=0.1)
base_otley = gp.read_file("./data/rnet_otley.geojson").to_crs(CRS)
base_otley["geometry"] = base_otley["geometry"].map(set_precision_pointone)
base_otley = combine_line(base_otley["geometry"]).to_frame("geometry")
otley_geometry = get_geometry_buffer(base_otley["geometry"], radius=buffer_size)

# Same for Armley:

base_armley = gp.read_file("./data/rnet_armley.geojson").to_crs(CRS)
base_armley["geometry"] = base_armley["geometry"].map(set_precision_pointone)
base_armley = combine_line(base_armley["geometry"]).to_frame("geometry")
armley_geometry = get_geometry_buffer(base_armley["geometry"], radius=buffer_size)
```

The buffered versions of the networks are presented below:

::: {#fig-buffered-network layout-ncol="2"}
```{python}
base_otley.plot(edgecolor="blue", color="blue")
```

```{python}
base_armley.plot(edgecolor="blue", color="blue")
```

```{python}
otley_geometry.plot(edgecolor="black", color="blue")
```

```{python}
armley_geometry.plot(edgecolor="black", color="blue")
```

Buffered versions of the Otley Road (left) and Armley Road (right) networks.
:::

```{python}
split_end = partial(split_ends, offset=np.sqrt(1.5) * radius)
otley_split = pd.DataFrame(base_otley["geometry"].map(split_end).to_list(), columns=["head", "centre", "tail"])
armley_split = pd.DataFrame(base_armley["geometry"].map(split_end).to_list(), columns=["head", "centre", "tail"])
```

::: {#fig-split-ends layout-ncol="2"}
```{python}
## overlapping
otley_centre = gp.GeoSeries(otley_split["centre"], crs=CRS)
otley_centre = gp.GeoSeries(otley_centre, crs=CRS).buffer(radius, 0, join_style="round", cap_style="round")

combined_otley = gp.GeoSeries(unary_union(otley_centre.values).geoms, crs=CRS)
combined_otley.plot()
```

```{python}
## overlapping
armley_centre = gp.GeoSeries(armley_split["centre"], crs=CRS)
armley_centre = gp.GeoSeries(armley_centre, crs=CRS).buffer(radius, 0, join_style="round", cap_style="round")
combined_armley = gp.GeoSeries(unary_union(armley_centre.values).geoms, crs=CRS)
combined_armley.plot()
```

Truncated and segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks.
:::

```{python}
i, j = base_otley.sindex.query(combined_otley, predicate="intersects")

base_otley["class"] = -1
base_otley.loc[j, "class"] = combined_otley.index[i]
count = base_otley.groupby("class").count()
base_otley = base_otley.join(count["geometry"].rename("count"), on="class")
ix = base_otley["class"] == -1
base_otley.loc[ix, "count"] = 0

i, j = base_armley.sindex.query(combined_armley, predicate="intersects")

base_armley["class"] = -1
base_armley.loc[j, "class"] = combined_armley.index[i]
count = base_armley.groupby("class").count()
base_armley = base_armley.join(count["geometry"].rename("count"), on="class")
ix = base_armley["class"] == -1
base_armley.loc[ix, "count"] = 0
```

::: {#fig-otley-armley-classes layout-ncol="2"}
```{python}
ix = base_otley["count"].isin([0, 1])
p = base_otley.loc[~ix, "geometry"].copy()
p = p.buffer(radius, 512, join_style="round", cap_style="round")
try:
    p = gp.GeoSeries(list(unary_union(p.values).geoms), crs=CRS)
except AttributeError:
    p = gp.GeoSeries(unary_union(p.values), crs=CRS)

q = base_otley.loc[ix, "geometry"].buffer(0.612, 64, join_style="mitre", cap_style="round")
otley_segment = pd.concat([p, q])
try:
    otley_segment = gp.GeoSeries(list(unary_union(otley_segment.values).geoms), crs=CRS)
except AttributeError:
    otley_segment = gp.GeoSeries(unary_union(otley_segment.values), crs=CRS)
otley_segment.plot()
```

```{python}
ix = base_armley["count"].isin([0, 1])
p = base_armley.loc[~ix, "geometry"].copy()
p = p.buffer(radius, 512, join_style="round", cap_style="round")
try:
    p = gp.GeoSeries(list(unary_union(p.values).geoms), crs=CRS)
except AttributeError:
    p = gp.GeoSeries(unary_union(p.values), crs=CRS)

q = base_armley.loc[ix, "geometry"].buffer(0.612, 64, join_style="mitre", cap_style="round")
armley_segment = pd.concat([p, q])
try:
    armley_segment = gp.GeoSeries(list(unary_union(armley_geometry.values).geoms), crs=CRS)
except AttributeError:
    armley_segment = gp.GeoSeries(unary_union(armley_segment.values), crs=CRS)
armley_segment.plot()
```

Segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks.
:::

### Skeletonization

The buffered lines are merged to create a raster image, which is then subjected to a thinning process to yield a skeletal remnant.
This remnant retains both the extent and connectivity of the original network, centered around a line that aligns with the combined buffered region.
This process is demonstrated using the Sample Street Network.

Establish an affine transformation that maps the points within the buffered geometry to corresponding positions in the raster image

A scaled affine transformation is calculated to align the projected coordinate geometry with the corresponding scaled raster image.

```{python}
import numpy as np
import pandas as pd
import rasterio as rio
import rasterio.features as rif

def get_pxsize(bound, scale=1.0):
    """get_pxsize: calculates scaled image size in px
      bound: boundary corner points
      scale: scaling factor (default = 1.0)
    returns:
      size in px
    """
    r = np.diff(bound.reshape(-1, 2), axis=0)
    r = np.ceil(r.reshape(-1))
    return (r[[1, 0]] * scale).astype(int)


def get_affine_transform(this_gf, scale=1.0):
    """get_affine_transform: return affine transformations matrices, and scaled image size
    from GeoPandas boundary size
      this_gf: GeoPanda
      scale:  (default = 1.0)
    returns:
      rasterio and shapely affine tranformation matrices, and image size in px
    """
    TRANSFORM_ONE = np.asarray([0.0, 1.0, -1.0, 0.0, 1.0, 1.0])
    bound = this_gf.total_bounds
    s = TRANSFORM_ONE / scale
    s[[4, 5]] = bound[[0, 3]]
    r = s[[1, 0, 4, 3, 2, 5]]
    r = rio.Affine(*r)
    return r, s, get_pxsize(bound, scale)

r_matrix_otley, s_matrix_otley, out_shape_otley = get_affine_transform(otley_geometry, scale=2.0)
# For Armle
r_matrix_armley, s_matrix_armley, out_shape_armley = get_affine_transform(armley_geometry, scale=2.0)
```

### Affine transforms

The affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0.
The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation, as illustrated in Table @tbl-panel.

```{python}
from IPython.display import display, Markdown
def display_matrix(matrix, header):
    r = matrix.to_markdown(index=False, headers=header)
    display(r)

or_matrix_otley = pd.DataFrame(np.asarray(r_matrix_otley).reshape(-1, 3))
os_matrix_otley = pd.DataFrame(np.asarray(s_matrix_otley).reshape(3, -1).T)

or_matrix_armley = pd.DataFrame(np.asarray(r_matrix_armley).reshape(-1, 3))
os_matrix_armley = pd.DataFrame(np.asarray(s_matrix_armley).reshape(3, -1).T)
```

::: {#tbl-panel layout-ncol="2"}
```{python}
#| output: asis
#| label: tbl-rasterio-transform
#| tbl-cap: Rasterio affine transformation matrix.
display_matrix(or_matrix_otley, "   ")
```

```{python}
#| output: asis
#| label: tbl-shapely-transform
#| tbl-cap: Shapely affine transformation matrix.
display_matrix(os_matrix_otley, "   ")
```

Rasterio and Shapely affine transformation matrices for the Otley Road network.
:::

In these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation.
The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.

### Skeletonize the buffer to a point geometry

A scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image.
This transformation adjusts the geometry to match the raster's scale and orientation.
Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles, resulting in raster representations illustrated in @fig-rasterize.
This step ensures a more coherent and accurate representation in the raster image.

```{python}
import warnings

from skimage.morphology import remove_small_holes, skeletonize
from shapely.affinity import affine_transform
from shapely.geometry import Point
import rasterio.plot as rip
```

::: {#fig-rasterize layout-ncol="2"}
```{python}
otley_im = rif.rasterize(otley_segment.values, transform=r_matrix_otley, out_shape=out_shape_otley)
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    otley_im = remove_small_holes(otley_im, 20).astype(np.uint8)

rip.show(otley_im, cmap="Greys", title="buffer geometry")
```

```{python}
armley_im = rif.rasterize(armley_segment.values, transform=r_matrix_armley, out_shape=out_shape_otley)
with warnings.catch_warnings():
    warnings.simplefilter("ignore")
    armley_im = remove_small_holes(armley_im, 20).astype(np.uint8)
rip.show(armley_im, cmap="Greys", title="buffer geometry")
```

Rasterized versions of the Otley Road (left) and Armley Road (right) networks, with post processing to remove small holes.
:::

The image undergoes a thinning process, yielding a skeletal raster image as the result.
This skeletonized image effectively captures the essential structure and layout of the original network, as illustrated in @fig-thin-skeleton.

::: {#fig-thin-skeleton layout-ncol="2"}
```{python}
otley_skeleton = skeletonize(otley_im).astype(np.uint8)
rip.show(otley_skeleton, cmap="Greys", title="skeleton geometry")
otley_p = np.stack(np.where(otley_skeleton >= 1))
otley_point = gp.GeoSeries(map(Point, otley_p.T), crs=CRS)
```

```{python}
armley_skeleton = skeletonize(armley_im).astype(np.uint8)
rip.show(armley_skeleton, cmap="Greys", title="skeleton geometry")
armley_p = np.stack(np.where(armley_skeleton >= 1))
armley_point = gp.GeoSeries(map(Point, armley_p.T), crs=CRS)
```

Skeletonized versions of the Otley Road (left) and Armley Road (right) networks.
:::

The rasterized skeletal image is then converted back into point geometry, completing the vector -\> raster -\> vector geometry transformation process.

<!-- Figure commented out as not necessary and similar to the subsequent figure: -->

<!-- ::: {#fig-skeleton-vector layout-ncol="2"} -->

```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_otley)
otley_transform = otley_point.map(shapely_transform).map(set_precision_pointone)
# otley_transform.plot(edgecolor="black", color="blue").grid()
# plt.show()
```

```{python}
armley_transform = armley_point.map(shapely_transform).map(set_precision_pointone)
# armley_transform.plot(edgecolor="black", color="blue").grid()
# plt.show()
```

```{=html}
<!-- Skeletonized versions of the Otley Road (left) and Armley Road (right) networks, transformed back into point geometry.

::: -->
```
The challenge with this approach is that instead of generating points situated on the simplified network, it returns a set of points rather than line geometries.
This necessitates the inference of line geometry from the associated set of points.
Transforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.

The process of transforming point geometry into line geometry involves identifying adjacent points based on proximity within the raster coordinate system, usually within a 1x1 pixel square.
After adjacent points are identified, line segments are created by connecting these points.
The final and crucial step is the amalgamation of these individual line segments.
This combination results in a continuous line geometry that represents the simplified network.
<!-- This conversion from point to line geometry is a pivotal aspect of network simplification. --> To visualize the simplified network in its original spatial context, the reverse affine transformation is applied.
This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework.
The resulting simplified network is illustrated in @fig-skeleton-line.

```{python}
from shapely import get_coordinates
from shapely.geometry import LineString, MultiLineString

def get_raster_line_with_knots(point):
    """get_raster_line_with_knots: return LineString GeoSeries from 1px line points with knots
    args:
      point: 1px point GeoSeries array with knots

    returns:
      1px line LineString GeoSeries with knots removed
    """
    square = point.buffer(1, cap_style="square", mitre_limit=1)
    ix = point.sindex.query(square, predicate="covers").T
    ix = np.sort(ix)
    s = pd.DataFrame(ix).drop_duplicates().reset_index(drop=True)
    s = s.loc[np.where(s[0] != s[1])]
    s = np.stack([point[s[0].values], point[s[1].values]]).T
    r = gp.GeoSeries(map(LineString, s), crs=CRS)
    edge, node = get_source_target(combine_line(r).to_frame("geometry"))
    return combine_line(edge["geometry"])

def get_end(geometry):
    """get_end: return numpy array of geometry LineString end-points
    args:
      geometry: geometry LineString

    returns:
      end-point numpy arrays
    """
    r = get_coordinates(geometry)
    return np.vstack((r[0, :], r[-1, :]))

def get_source_target(line):
    """get_source_target: return edge and node GeoDataFrames from LineString with unique
    node Point and edge source and target

    args:
      line: LineString GeoDataFrame

    returns:
      edge, node: GeoDataFrames
    """
    edge = line.copy()
    r = edge["geometry"].map(get_end)
    r = np.stack(r)
    node = gp.GeoSeries(map(Point, r.reshape(-1, 2)), crs=CRS).to_frame("geometry")
    count = node.groupby("geometry").size().rename("count")
    node = node.drop_duplicates("geometry").set_index("geometry", drop=False)
    node = node.join(count).reset_index(drop=True).reset_index(names="node")
    ix = node.set_index("geometry")["node"]
    edge = edge.reset_index(names="edge")
    edge["source"] = ix.loc[map(Point, r[:, 0])].values
    edge["target"] = ix.loc[map(Point, r[:, 1])].values
    return edge, node

def combine_line(line):
    """combine_line: return LineString GeoSeries combining lines with intersecting endpoints
    args:
      line: mixed LineString GeoSeries
    returns:
      join LineString GeoSeries

    """
    r = MultiLineString(line.values)
    return gp.GeoSeries(line_merge(r).geoms, crs=CRS)

otley_line = get_raster_line_with_knots(otley_point)
armley_line = get_raster_line_with_knots(armley_point)
```

::: {#fig-skeleton-line layout-ncol="2"}
```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_otley)
otley_sk = otley_line.map(shapely_transform).map(set_precision_pointone)
otley_sk = otley_sk.set_crs(CRS)
otley_sk.plot()
```

```{python}
shapely_transform = partial(affine_transform, matrix=s_matrix_armley)
armley_sk = armley_line.map(shapely_transform).map(set_precision_pointone)
armley_sk = armley_sk.set_crs(CRS)
armley_sk.plot()
```

Simplified versions of the Otley Road (left) and Armley Road (right) networks, transformed back into line geometry.
:::

### Knots

Knots in the network are multiple short segments at intersections, resembling tangled knots.
To remove these features of networks, which add complexity that is rarely relevant for strategic transport planning, short segments are clustered together, and a central point for each cluster is determined.
The end-points of longer lines that connect to these segment clusters are then realigned to the cluster's central point.
This process effectively removes the knot-like appearance.
As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context, as illustrated in @fig-knots.

```{python}
import networkx as nx
from shapely.geometry import MultiPoint

def get_raster_line_without_knot(this_line):
    """get_raster_line_without_knot: remove knots from LineString GeoSeries
    args:
      this_line: LineString GeoSeries array with knots
    returns:
      LineString GeoSeries with knots removed
    """
    edge, node = get_source_target(this_line)
    ix = edge.length > 2.0
    connected = get_connected_class(edge.loc[~ix, ["source", "target"]])
    node = node.loc[connected.index].join(connected).sort_index()
    connected_edge = get_centre(node)
    r = combine_line(pd.concat([connected_edge["geometry"], edge.loc[ix, "geometry"]]))
    return r[r.length > 2.0]


def get_connected_class(edge):
    """get_connected_class: return labeled connected node pandas Series from edge list
    args:
      edge_list: source, target edge pandas DataFrame
    returns:
      labeled node pandas Series
    """
    nx_graph = nx.from_pandas_edgelist(edge)
    connected = nx.connected_components(nx_graph)
    r = {k: i for i, j in enumerate(connected) for k in j}
    return pd.Series(r, name="class")

def get_centre(node):
    """get_centre_edge: return centroid Point from discrete node clusters
    args:
      node: discrete node cluster GeoDataSeries
    returns:
      GeoDataCentre node cluster centroid Point
    """
    centre = node[["geometry", "class"]].groupby("class").aggregate(tuple)
    centre = gp.GeoSeries(centre["geometry"].map(MultiPoint), crs=CRS).centroid
    centre = centre.rename("target")
    geometry = node[["class", "geometry"]].set_index("class").join(centre)
    geometry = geometry.apply(LineString, axis=1)
    r = node.rename(columns={"node": "source"}).copy()
    r["geometry"] = geometry.values
    return r
```

::: {#fig-knots layout-ncol="2"}
![](images/knot-output.png){#fig-knot}

![](images/noknot-output.png){#fig-noknot}

Zoomed in versions of road structure with knots (left), and with knots removed (right) shown in @fig-knots.
:::

### Primal network

There are circumstances where it might be beneficial to view a "primal" network, which is exclusively composed of direct lines connecting start and end points.
This primal network represents an extreme form of simplification, of great potential value in situations in which the network's overall structure and compression ratios are priorities.
The primal networks for the Otley Road and Armley Road networks are illustrated in @fig-primal.

```{python}
def get_nx(line):
    """get_nx: return primal edge and node network from LineString GeoDataFrame
    args:
      line: LineString GeoDataFrame
    returns:
      edge, node GeoDataFrames
    """
    r = line.map(get_end)
    edge = gp.GeoSeries(r.map(LineString), crs=CRS)
    r = np.vstack(r.to_numpy())
    r = gp.GeoSeries(map(Point, r)).to_frame("geometry")
    r = r.groupby(r.columns.to_list(), as_index=False).size()
    return edge
```

::: {#fig-primal layout-ncol="2"}
```{python}
otley_edge_sk = get_nx(otley_sk)
otley_edge_sk.plot()
```

```{python}
armley_edge_sk = get_nx(armley_sk)
armley_edge_sk.plot()
```

Primal networks for the Otley Road (left) and Armley Road (right) networks.
:::

## Simplification via Voronoi polygons

In this approach, the network lines are first buffered as described above.
The edges of these buffers are then segmented into sequences of points.
From these sequences, a centre-line is derived based on a set of Voronoi polygons that cover these points.
This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.

### Boundary Segmentation

The boundary of the buffered input geometry is calculated and simplified, giving a simplified GeoSeries of LineStrings, correctly aligned with a specified coordinate reference system (CRS).
This functionality is particularly useful in geographic information systems (GIS) for delineating and visualizing precise boundaries of spatinal objects.
The code demonstrates its utility by applying the function to a geometry (otley_geometry) and visualizing the resultant simplified boundaries (otley_boundary), highlighting its practical application in spatial analysis and network simplification.
The simplified LineString geometries are then broken down into shorter segments.

```{python}
from shapely import box
from shapely.ops import voronoi_diagram

scale = 5.0
tolerance = 0.1

otley_clip = box(426800, 437400, 427000, 437600)
armley_clip = box(427200, 433500, 427400, 433700)

def get_geometry_line(this_buffer):
    """get_geometry_line: returns LineString boundary from geometry
    args:
      this_buffer: geometry to find LineString
    returns:
       simplified LineString boundary
    """
    r = this_buffer.boundary.explode(index_parts=False).reset_index(drop=True)
    return gp.GeoSeries(r.simplify(tolerance=0.5), crs=CRS)
```

::: {#fig-boundary layout-ncol="2"}
```{python}
otley_boundary = get_geometry_line(otley_geometry)
otley_boundary.plot()
```

```{python}
armley_boundary = get_geometry_line(armley_geometry)
armley_boundary.plot()
```

Simplified boundaries of the Otley Road (left) and Armley Road (right) networks.
:::

```{python}
def get_segment_nx(line, scale):
    """get_segment_nx: segment line into sections, no more than scale long
    args:
      line:  line to segment
      scale: length to segment line
    returns:
      segmented LineStrings
    """
    set_segment = partial(get_segment, distance=scale)
    r = line.map(set_segment).explode().rename("geometry")
    return gp.GeoDataFrame(r, crs=CRS)

def get_linestring(line):
    """get_linestring: return LineString GeoSeries from line coordinates
    args:
      line:
    returns:
       LineString GeoSeries
    """
    r = get_coordinates(line)
    r = np.stack([gp.points_from_xy(*r[:-1].T), gp.points_from_xy(*r[1:].T)])
    return gp.GeoSeries(pd.DataFrame(r.T).apply(LineString, axis=1), crs=CRS).values

def get_segment(line, distance=50.0):
    """get_segment: segment LineString GeoSeries into distance length segments
    args:
      line: GeoSeries LineString
      length: segmentation distance (default value = 50.0)
    returns:
      GeoSeries of LineStrings of up to length distance
    """
    return get_linestring(line.segmentize(distance))

def get_skeleton(geometry, transform, shape):
    """get_skeleton: return skeletonized raster buffer from Shapely geometry

    args:
      geometry: Shapely geometry to convert to raster buffer
      transform: rasterio affine transformation
      shape: output buffer px size

    returns:
      skeltonized numpy array raster buffer

    """
    r = rif.rasterize(geometry.values, transform=transform, out_shape=shape)
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        r = remove_small_holes(r, 4).astype(np.uint8)
    return skeletonize(r).astype(np.uint8)

def get_raster_line(point, knot=False):
    """get_raster_line: return LineString GeoSeries from 1px line raster eliminating knots

    args:
      point: 1px raster array with knots

    returns:
      1px line LineString GeoSeries with knots removed

    """
    square = point.buffer(1, cap_style="square", mitre_limit=1)
    ix = point.sindex.query(square, predicate="covers").T
    ix = np.sort(ix)
    s = pd.DataFrame(ix).drop_duplicates().reset_index(drop=True)
    s = s.loc[np.where(s[0] != s[1])]
    s = np.stack([point[s[0].values], point[s[1].values]]).T
    r = gp.GeoSeries(map(LineString, s), crs=CRS)
    edge, node = get_source_target(combine_line(r).to_frame("geometry"))
    if knot:
        return combine_line(edge["geometry"])
    ix = edge.length > 2.0
    connected = get_connected_class(edge.loc[~ix, ["source", "target"]])
    node = node.loc[connected.index].join(connected).sort_index()
    connected_edge = get_centre(node)
    r = combine_line(pd.concat([connected_edge["geometry"], edge.loc[ix, "geometry"]]))
    return r[r.length > 2.0]
```

::: {#fig-segment layout-ncol="2"}
```{python}
otley_segment = get_segment_nx(otley_boundary, scale).reset_index(drop=True)
ax = otley_segment.clip(otley_clip).plot(edgecolor="red", linestyle='--', linewidth=1)
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
armley_segment = get_segment_nx(armley_boundary, scale).reset_index(drop=True)
ax = armley_segment.clip(armley_clip).plot(edgecolor="red", linestyle='--', linewidth=1)
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

Detail segmented boundaries of the Otley Road (left) and Armley Road (right) networks.
:::

The simplified `LineString` geometries are converted into point geometries, detail @fig-voronoi-point.

::: {#fig-voronoi-point layout-ncol="2"}
```{python}
otley_point = otley_segment.loc[:, "geometry"].map(get_coordinates).explode()
otley_point = MultiPoint(otley_point[::2].map(Point).values)
nx_output = gp.GeoSeries(otley_point, crs=CRS)
ax = nx_output.clip(otley_clip).plot(edgecolor="blue", color="white")
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
armley_point = armley_segment.loc[:, "geometry"].map(get_coordinates).explode()
armley_point = MultiPoint(armley_point[::2].map(Point).values)
nx_output = gp.GeoSeries(armley_point, crs=CRS)
ax = nx_output.clip(armley_clip).plot(edgecolor="blue", color="white")
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

Detail point segement of the Otley Road (left) and Armley Road (right) networks.
:::

<!-- we probably want to pick Voronoi #1 or Voronoi #2. I'd marginally favour #2 -->

### Voronoi diagram

The corresponding Voronoi diagrams is generated and clipped to the bounds of input geometry, as illustrated in @fig-voronoi-2 figures below.

<!-- ::: {#fig-voronoi layout-ncol="2"} -->

```{python}
otley_envelope = box(*otley_point.bounds)
otley_voronoi = voronoi_diagram(otley_point, envelope=otley_envelope, tolerance=tolerance, edges=True)
otley_voronoi = gp.GeoSeries(map(set_precision_pointone, otley_voronoi.geoms), crs=CRS)
#ax = otley_voronoi.plot()
#ax.xaxis.set_ticklabels([])
#ax.yaxis.set_ticklabels([])
```

```{python}
armley_envelope = box(*armley_point.bounds)
armley_voronoi = voronoi_diagram(armley_point, envelope=armley_envelope, tolerance=tolerance, edges=True)
armley_voronoi = gp.GeoSeries(map(set_precision_pointone, armley_voronoi.geoms), crs=CRS)
#ax = armley_voronoi.plot()
#ax.xaxis.set_ticklabels([])
#ax.yaxis.set_ticklabels([])
```

```{=html}
<!-- Clipped Voronoi diagrams of the Otley Road (left) and Armley Road (right) networks.

<!-- ::: -->
```
<!-- ### Voronoi 2 -->

::: {#fig-voronoi-2 layout-ncol="2"}
```{python}
otley_voronoi = otley_voronoi.explode(index_parts=False).clip(otley_envelope)
ix = ~otley_voronoi.is_empty & (otley_voronoi.type == "LineString")
otley_voronoi = otley_voronoi[ix].reset_index(drop=True)
ax = otley_voronoi.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
armley_voronoi = armley_voronoi.explode(index_parts=False).clip(armley_envelope)
ix = ~armley_voronoi.is_empty & (armley_voronoi.type == "LineString")
armley_voronoi = armley_voronoi[ix].reset_index(drop=True)
ax = armley_voronoi.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

Clipped Voronoi diagrams of the Otley Road (left) and Armley Road (right) networks.
:::

<!-- ### Voronoi simplified network -->

```{python}
offset = buffer_size / 2.0

def get_voronoi_line(voronoi, boundary, geometry, buffer_size):
    """get_voronoi_line: returns cleaned simplified line by filtering Voronoi lines by distance,
    contained within network buffer Polygons, and combining overlapping end-points

    args:
      voronoi:     Voronoi LineString
      boundary:    network buffer LineString
      geometry:    network buffer Polygon
      buffer_size: network buffer distance [m]
    returns:
      simplified simplified network line
    """
    offset = buffer_size / 2.0
    r = filter_distance(voronoi, boundary, offset)
    r = filter_buffer(r, geometry)
    edge, node = get_source_target(r.to_frame("geometry"))
    ix = node["count"] < 4
    square = node[ix].buffer(offset, cap_style="square", mitre_limit=offset)
    square = gp.GeoSeries(unary_union(square.values).geoms, crs=CRS)
    r = edge["geometry"].map(get_linestring).explode().to_frame("geometry")
    r = set_geometry(r, square)
    return combine_line(r)

def filter_distance(line, boundary, offset):
    """filter_distance: filter line closer than distance offset from boundary
    args:
      line:     LineStrings to simplify
      boundary: boundary LineString
      offset:
    returns:
      simplified LineStrings
    """
    edge, _ = get_source_target(line.to_frame("geometry"))
    (ix, _), distance = boundary.sindex.nearest(edge["geometry"], return_distance=True)
    _, ix = np.unique(ix, return_index=True)
    ix = distance[ix] > offset
    return combine_line(edge.loc[ix, "geometry"]).simplify(1.0)

def filter_buffer(line, geometry):
    """filter_buffer: filter keeping lines within boundary Polygon
    args:
      line:     LineStrings to simplify
      geometry: boundary Polygon
    returns:
      filtered LineStrings
    """
    (_, ix) = line.sindex.query(geometry, predicate="contains_properly")
    return combine_line(line.loc[ix]).simplify(1.0)


def set_geometry(line, square):
    """set_geometry: return LineString simplified by combining overlapping end-points

    args:
      line:     LineStrings to simplify
      square:   overlapping squares
    returns:
      simplified LineStrings
    """
    r = line.reset_index(drop=True)
    centroid = square.centroid.map(set_precision_pointone).set_crs(CRS)
    edge, node = get_source_target(r)
    ix = node["geometry"].sindex.query(square, predicate="contains_properly")
    node.loc[ix[1], "geometry"] = centroid[ix[0]].values
    source = node.loc[edge["source"], "geometry"].values
    target = node.loc[edge["target"], "geometry"].values
    r = np.stack([source, target]).T
    return gp.GeoSeries(map(LineString, r), crs=CRS)

def get_voronoi(this_buffer, tolerance, scale):
    """voronoi_nx: return Voronoi polygon using segmented points from the buffer

    args:
      this_buffer: segmented
      tolerance:   distance to snap input vertices
      scale:       distance between segment boundary points

    returns:
      Voronoi polygon
    """
    segment = get_segment_nx(this_buffer, scale).reset_index(drop=True)
    point = segment.loc[:, "geometry"].map(get_coordinates).explode()
    point = MultiPoint(point[::2].map(Point).values)
    boundary = box(*point.bounds)
    r = voronoi_diagram(point, envelope=boundary, tolerance=tolerance, edges=True)
    r = gp.GeoSeries(map(set_precision_pointone, r.geoms), crs=CRS)
    r = r.explode(index_parts=False).clip(boundary)
    ix = ~r.is_empty & (r.type == "LineString")
    return r[ix].reset_index(drop=True)

#nx_line = get_voronoi_line(nx_voronoi, nx_boundary, otley_geometry, buffer_size)
```

The centre-line is derived based by excluding lines making up the Voronoi diagrams that are at a distance of more than half-the-buffer-size from the buffer-edge, and is completely within the buffered geometry @fig-voronoi-simplified.

::: {#fig-voronoi-simplified layout-ncol="2"}
```{python}
otley_line = filter_distance(otley_voronoi, otley_boundary, offset)
otley_line.plot()
```

```{python}
armley_line = filter_distance(armley_voronoi, armley_boundary, offset)
armley_line.plot()
```

Voronoi diagram lines with lines that are completely within the buffer geometry and less than half-a-buffer-width from the buffer edge.
:::

### Voronoi simplified network

The centre-line network as shown in @fig-voronoi-line is then generated by removing knot-like features from the resulting network.

::: {#fig-voronoi-line layout-ncol="2"}
```{python}
otley_line = filter_buffer(otley_line, otley_geometry)
otley_edge, otley_node = get_source_target(otley_line.to_frame("geometry"))
ix = otley_node["count"] < 4
otley_square = otley_node[ix].buffer(offset, cap_style="square", mitre_limit=offset)
otley_square = gp.GeoSeries(unary_union(otley_square.values).geoms, crs=CRS)
otley_line = otley_edge["geometry"].map(get_linestring).explode().to_frame("geometry")
otley_line = set_geometry(otley_line, otley_square)
otley_line = combine_line(otley_line)
otley_line.plot()
```

```{python}
armley_line = filter_buffer(armley_line, armley_geometry)
armley_edge, armley_node = get_source_target(armley_line.to_frame("geometry"))
ix = armley_node["count"] < 4
armley_square = armley_node[ix].buffer(offset, cap_style="square", mitre_limit=offset)
armley_square = gp.GeoSeries(unary_union(armley_square.values).geoms, crs=CRS)
armley_line = armley_edge["geometry"].map(get_linestring).explode().to_frame("geometry")
armley_line = set_geometry(armley_line, armley_square)
armley_line = combine_line(armley_line)
armley_line.plot()
```

Simplified versions of the Otley Road (left) and Armley Road (right) networks.
:::

<!-- ### Primal network -->

The primal network associated with the voronoi approach is illustrated in @fig-primal-voronoi.

::: {#fig-primal-voronoi layout-ncol="2"}
```{python}
otley_edge = get_nx(otley_line)
otley_edge.plot()
```

```{python}
armley_edge = get_nx(armley_line)
armley_edge.plot()
```

Figure 12: Primal networks for the Otley Road (left) and Armley Road (right) networks.
:::

<!-- ![](images/paste-1.png) -->

## Joining route networks

After a simplified network has been generated, using a the methods outlined in the previous section or through a separate process, the next step is to translate the values of attributes from the detailed network to the simplified network.
The process can also be referred to as 'conflation' and 'integration': "Conflation is desired because the source file may be attribute rich (street names, address ranges, zip codes) but positionally poor: the target file may be positionally precise but attribute poor ... There are two aspects to network data integration, namely: the integration of the geometry, such as the link and node feature elements; and integration of the attributes, such as the highway data" [@sutton1998].
In this case we seek to integrate the attributes from the source detailed network with the simplified target geometry.

This 'joining' step is vital for using simplified networks as the basis for presenting model outputs.
In instances where a simplified version of the network is readily available, such as the Ordnance Survey's Open Roads dataset in the UK, the steps for network simplification can be bypassed to save time.
We have implemented the steps presented in this section in the `rnet_merge()` function in the `stplanr` R package.

The process is analogous to joining two datasets based on a common 'key' variable.
In this case there is no definitive key, meaning that network joining can be regarded as a 'fuzzy' or 'keyless' join process [@suri; @wachowicz2019]: as with the network simplification steps outlined above, the user must select joining parameters to maximise the accuracy of the join.

<!-- **Data Preparation:** -->

The main inputs of the network merging function are two route networks: `rnet_x` (the simple network geometry) and `rnet_y` (the original network with a more complex geometry and attributes that need to be translated onto the new network).
`rnet_x` can also be referred to as the 'target' object, following the terminology used to describe database and 'spatial similarity' joins [@ballesteros2011].
`rnet_y` in this case represents the detailed network with attributes such as model outputs representing transport flows to be translated onto the new network.

<!-- **Step 1: Coordinate Reference System Alignment** -->

```{=html}
<!-- Transform the spatial data of both `rnet_x` (the simplified network) and `rnet_y` (the detailed network) to the same coordinate reference system.
For this project, we have selected EPSG:27700. -->
```
```{r}
#| echo: false
#| eval: false
rnet_xp = sf::st_transform(rnet_x, "EPSG:27700")
rnet_yp = sf::st_transform(rnet_y, "EPSG:27700")
```

<!-- **Step 2: Defining the Function List** -->

```{=html}
<!-- Create a function list that dictates how each attribute is to be processed:

-   **Exclude**: "geometry" from processing.

-   **Mean Function**: Applied to attributes like "Gradient" and "Quietness".
    TODO expline the funtion of sum and mean

-   **Sum Function**: Used for aggregating values in columns such as "all_bicycle".

**Step 3: Using `stplanr::rnet_merge` for Integration**

Employ the `rnet_merge` function from the `stplanr` package.
This function is designed to merge route network data, taking into account the predefined functions and alignment in the coordinate system. -->
```
```{r}
#| eval: false
#| echo: false
rnet_merged = stplanr::rnet_merge(rnet_xp, rnet_yp, dist = 20, segment_length = 10, funs = funs, max_angle_diff = 30) 
```

The network joining function can also take a number of arguments that define how the attributes are translated to the simplified target network:

-   **`dist`** (Buffer Distance): This parameter defines the buffer zone around `rnet_xp` in meters, for determining the proximity at which features from both networks are considered for merging.
    Typically, this value is refined to approximate the width of streets, ensuring a realistic spatial correlation between the network elements.

-   **`segment_length`** (Maximum Segment Length): This optional argument (with 0 being the default meaning no splitting) specifies the maximum length of segments in `rnet_y` before they are split.
    Segmenting long segments in the detailed network reduces number of source geometries that do not fit within target geometries, which can be key for achieving higher accuracy in attribute integration.
    <!-- Todo: discuss possibility of cutting lines at buffer intersections. -->

-   **`funs`** (Function List): Comprises a series of key-value pairs representing variable names and the function to apply to each.
    Any function can be used, with sum and mean being typical values.

-   **`max_angle_diff`** (Maximum Angular Difference): This argument specifies the maximum angular difference between segments and target lines for values in matching source geometries to be translated to the target simplified geometries.
    A low value, such as 20 degrees, ensures that values are translated only to segments with similar orientations, preventing overestimation of values on side roads.

```{=html}
<!-- An optional `sum_flows` argument can be used to ensure that more influential lines have a proportionate impact on the final aggregated value for each geometry in the simplified network.
The formula for the weighted sum is:

$$
\text{Weighted Sum} = \sum (x_i \times w_i)
$$

Where `xi` represents the attribute value for the i-th line in the complex network, and `wi` is the length weight for the i-th line. -->
```
An optional normalization step adjusts the values associated with each simplified feature such that the total flow on complex and simplified networks are equal.
Normalization captures the fact that simplified networks are likely to have a smaller total length and be less circuitous.
The normalization formula is:

$$
\text{Normalized Value} = \frac{\text{Weighted Sum}}{\sum w_i}
$$

The formula is as follows:

$$
\text{over\_estimate} = \frac{\sum(\text{Aggregated Value} \times \text{Length of Single Line})}{\sum(\text{Original Value} \times \text{Length of Lines in Complex Network})}
$$

$$
\text{Adjusted Value} = \frac{\text{Normalized Value}}{\text{over\_estimate}}
$$

<!-- Content for long form appendix?: -->

````{=html}
<!-- To calculate max_angle_diff, it's necessary to accurately calculate the angles (bearings) of lines from two networks, rnet_x$angle_x and rnet_y$angle_y.
The difference in these angles is then computed as rnetj$angle_diff <- rnetj$angle_y - rnetj\$angle_x.
In this study, the line_bearing function is defined to calculate the angle.
As shown below,

```         
rnet$angle = line_bearing(rnet_y, bidirectional = TRUE)
```

The process of calculating the bidirectional bearing of a line segment in geographical coordinates involves normalizing the standard bearing so that it is the same regardless of the direction of travel along the line.
Below is the detailed formula:

1.  **Convert Latitudes and Longitudes to Radians**:

$$
\text{lat}_1 = \text{lat}_1 \times \frac{\pi}{180}
$$

$$
\text{lat}_2 = \text{lat}_2 \times \frac{\pi}{180}
$$

$$
\text{lon}_1 = \text{lon}_1 \times \frac{\pi}{180}
$$

$$
\text{lon}_2 = \text{lon}_2 \times \frac{\pi}{180}
$$

2.  **Calculate Bearing**:

$$
\Delta lon = lon_2 - lon_1
$$

$$
\theta = atan2(\sin(\Delta lon) \times \cos(lat_2), \cos(lat_1) \times \sin(lat_2) - \sin(lat_1) \times \cos(lat_2) \times \cos(\Delta lon))
$$

3.  **Convert Bearing from Radians to Degrees and Normalize Bidirectional Bearing to \[0, 180) Degrees**:

$$
\theta = \theta \times \frac{180}{\pi}
$$

$$
\theta = \theta \mod 180
$$

In this bidirectional adjustment, the bearing is normalized to a range of \[0, 180) degrees.
This means that opposite directions along a line yield the same bearing value.
This approach is particularly useful in scenarios where the directionality of the line is not a primary concern, ensuring consistency in bearing values regardless of the line's travel direction. -->
````

<!-- ![image](pics/Prevent_overestimate_of_values_on_sideroads.png) -->

```{r}
rnet_xp = st_transform(rnet_x, "EPSG:27700")
rnet_yp = st_transform(rnet_y, "EPSG:27700")

# Extract column names from the rnet_yp
name_list = names(rnet_yp)

# Initialize an empty list
funs = list()

# Loop through each name and assign it a function based on specific conditions
for (name in name_list) {
  if (name == "geometry") {
    next  # Skip the current iteration
  } else if (name %in% c("Gradient", "Quietness")) {
    funs[[name]] = mean
  } else {
    funs[[name]] = sum
  }
}

dist = 20
rnet_merged_with_angle = stplanr::rnet_merge(rnet_xp, rnet_yp, dist = dist, segment_length = 10, funs = funs, max_angle_diff = 20)
rnet_merged_without_angle= stplanr::rnet_merge(rnet_xp, rnet_yp, dist = dist, segment_length = 10, funs = funs)

# Define breaks for the color scale
brks = c(0, 100, 500, 1000, 5000)

# Set global tmap options for tighter margins
tmap_options(
  outer.margins = c(0, 0, 0, 0),
  inner.margins = c(0, 0, 0, 0)
)

# Create the first map with scale bar
m1 = tm_shape(rnet_merged_with_angle) + 
     tm_lines("value", palette = "viridis", lwd = 5, breaks = brks) +
     tm_scale_bar() +
     tm_layout(frame = FALSE, inner.margins = 0, outer.margins = 0, asp = 0)

# Create the second map
m2 = tm_shape(rnet_merged_without_angle) + 
     tm_lines("value", palette = "viridis", lwd = 5, breaks = brks) +
     tm_layout(frame = FALSE, inner.margins = 0, outer.margins = 0, asp = 0)

# Arrange the two maps vertically with a tight layout and synchronization
tmap_arrange(m1, m2, nrow = 2, sync = TRUE)
```

After the joining process has completed, a series of post-processing steps can refine the results:

-   **Cleaning**: The `rnet_merged` dataset undergoes an initial cleaning phase where superfluous columns are removed.
    This step enhances dataset manageability and focuses on relevant data by eliminating columns such as 'identifier' and 'length_x'.

-   **Dimensionality Reduction**: Z and M dimensions are removed from the dataset, as they are redundant for our analysis and contribute to unnecessary increases in file size.
    This reduction simplifies the dataset and optimizes it for storage and processing efficiency.

-   **NA Handling**: A thorough examination is conducted for the presence of NA values across the columns.
    Any rows where all the targeted columns contain NA values are filtered out.

-   **Spatial Subsetting**: Following the removal of linestrings that contain NA attributes from the `rnet_merged` dataset, we proceed to create a geometric buffer zone.
    This zone serves as a spatial criterion for identifying and retaining only those geometries that lie outside of this buffer.
    A subset of `rnet_yp`, termed `rnet_yp_rest`, is then delineated based on this spatial relationship, effectively omitting any geometries that intersect with or fall within the buffered area.
    This step ensures that only those components of `rnet_y` which are spatially distinct from `rnet_merged` are retained for further consideration.

-   **Network Simplification**: In the final stage of simplification, the datasets `rnet_yp_rest` and `rnet_merged_all` are combined to form the final network, which retains the simplicity of the original simplified structure while concurrently encompassing the detailed attributes, thereby providing a comprehensive yet efficient foundation for further analysis.

These steps can be tailored to the specific needs of the analysis.

```{python}
rnet_x = gp.read_file("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_x_ed.geojson")
rnet_y = gp.read_file("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson")
# Plotting both GeoJSON files side by side
fig, axes = plt.subplots(1, 2, figsize=(15, 8))

rnet_x.plot(ax=axes[0], color='blue')
axes[0].set_title('RNet X')

rnet_y.plot(ax=axes[1], color='green')
axes[1].set_title('RNet Y')

plt.tight_layout()
plt.show()
```

<!-- TODO: add content to this section. -->

<!-- TODO: Is this possible? -->

<!-- ## Combined network simplification and attribute merging -->

# Results

Some results in column order Armley, Edinburgh, Doncaster rail.
Rows 1 input, 2 skeltonized, 3 voronoi, 4 primal skeletonized, 5 primal voronoi

```{python}
PLOT_DATA = ("base_armley,base_edinburgh,base_doncaster,armley_sk,edinburgh_sk,doncaster_sk,"
             "armley_line,edinburgh_line,doncaster_line,armley_edge_sk,edinburgh_edge_sk,"
             "doncaster_edge_sk,armley_edge,edinburgh_edge,doncaster_edge").split(",")

from pathlib import Path
for variable in PLOT_DATA:
    filepath = Path(f"data/rnet_{variable}.geojson")
    if variable in globals():
        continue
    if filepath.exists():
        data = gp.read_file(filepath)
        globals()[variable] = data
```

```{python}
if "edinburgh_sk" not in globals():
    base_edinburgh = gp.read_file("./data/rnet_princes_street.geojson").to_crs(CRS)
    edinburgh_geometry = get_geometry_buffer(base_edinburgh["geometry"], radius)
    r_matrix_edinburgh, s_matrix_edinburgh, out_shape_edinburgh = get_affine_transform(
        edinburgh_geometry, scale=2.0
    )
    shapely_transform = partial(affine_transform, matrix=s_matrix_edinburgh)
    edinburgh_skeleton = get_skeleton(
        edinburgh_geometry, r_matrix_edinburgh, out_shape_edinburgh
    )
    edinburgh_p = np.stack(np.where(edinburgh_skeleton >= 1))
    edinburgh_point = gp.GeoSeries(map(Point, edinburgh_p.T), crs=CRS)
    edinburgh_line = get_raster_line(edinburgh_point)
    edinburgh_sk = edinburgh_line.map(shapely_transform).map(set_precision_pointone)
    edinburgh_sk = gp.GeoSeries(edinburgh_sk, crs=CRS)
    edinburgh_edge_sk = get_nx(edinburgh_sk)

if "doncaster_sk" not in globals():
    base_doncaster = gp.read_file("./data/rnet_doncaster_rail.geojson").to_crs(CRS)
    doncaster_geometry = get_geometry_buffer(base_doncaster["geometry"], radius)
    r_matrix_doncaster, s_matrix_doncaster, out_shape_doncaster = get_affine_transform(
        doncaster_geometry, scale=2.0
    )
    shapely_transform = partial(affine_transform, matrix=s_matrix_doncaster)
    doncaster_skeleton = get_skeleton(
        doncaster_geometry, r_matrix_doncaster, out_shape_doncaster
    )
    doncaster_p = np.stack(np.where(doncaster_skeleton >= 1))
    doncaster_point = gp.GeoSeries(map(Point, doncaster_p.T), crs=CRS)
    doncaster_line = get_raster_line(doncaster_point)
    doncaster_sk = doncaster_line.map(shapely_transform).map(set_precision_pointone)
    doncaster_sk = gp.GeoSeries(doncaster_sk, crs=CRS)
    doncaster_edge_sk = get_nx(doncaster_sk)
```

```{python}
if "edinburgh_edge" not in globals():
    edinburgh_boundary = get_geometry_line(edinburgh_geometry)
    edinburgh_voronoi = get_voronoi(edinburgh_boundary, tolerance, scale)
    edinburgh_line = get_voronoi_line(
        edinburgh_voronoi, edinburgh_boundary, edinburgh_geometry, radius
    )
    edinburgh_line = edinburgh_line.simplify(1.0)
    edinburgh_edge = get_nx(edinburgh_line)

if "doncaster_edge" not in globals():
    doncaster_boundary = get_geometry_line(doncaster_geometry)
    doncaster_voronoi = get_voronoi(doncaster_boundary, tolerance, scale)
    doncaster_line = get_voronoi_line(
        doncaster_voronoi, doncaster_boundary, doncaster_geometry, radius
    )
    doncaster_line = doncaster_line.simplify(1.0)
    doncaster_edge = get_nx(doncaster_line)
```

```{python}
for variable in PLOT_DATA:
    filepath = Path(f"data/rnet_{variable}.geojson")
    if filepath.exists():
        continue
    if variable in globals():
        data = globals()[variable]
        data.to_file(filepath)
```

::: {#fig-results layout-ncol="3" layout-nrow="5"}
```{python}
# 1 1
ax = base_armley.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 1 2
ax = base_edinburgh.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 1 3
ax = base_doncaster.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 2 1
ax = armley_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 2 2
ax = edinburgh_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 2 3
ax = doncaster_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 3 1
ax = armley_line.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 3 2
ax = edinburgh_line.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 3 3
ax = doncaster_line.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 4 1 Voronoi
ax = armley_edge_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 4 2
ax = edinburgh_edge_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 4 3
ax = doncaster_edge_sk.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 5 1 Voronoi primal
ax = armley_edge.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 5 2
ax = edinburgh_edge.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

```{python}
# 5 3
ax = doncaster_edge.plot()
ax.xaxis.set_ticklabels([])
ax.yaxis.set_ticklabels([])
```

Results diagrams
:::

# Discussion {#sec-discussion}

-   Optimisation

-   Packaging

-   

# References

<!-- Tests -->

```{python}
# osmnx test:
# import osmnx as ox
# import geopandas as gpd
# import momepy
# import networkx as nx
# import topojson as tp

# gdf = gpd.read_file("https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson")
# # Convert to EPSG:27700
# gdf = gdf.to_crs('EPSG:27700')
# gdf.plot()
# gdf_topo = tp.Topology(gdf)
# gdf_simple = gdf_topo.toposimplify(10).to_gdf()
# gdf_simple.plot()
# # Convert gdf linestrings to nodes:
# gdf_nx = momepy.gdf_to_nx(gdf, approach='dual')
# nx.draw(gdf_nx)
# momepy.roundabout_simplification(gdf)
```

```{python}
# import osmnx as ox
# import geopandas as gpd
# import momepy
# import networkx as nx
# import topojson as tp

# gdf = gpd.read_file('data/minimal-input.geojson')
# # Convert to EPSG:27700
# gdf = gdf.to_crs('EPSG:27700')
# gdf.plot()
# gdf_topo = tp.Topology(gdf)
# gdf_simple = gdf_topo.toposimplify(10).to_gdf()
# gdf_simple.plot()
# # Convert gdf linestrings to nodes:
# gdf_nx = momepy.gdf_to_nx(gdf, approach='dual')
# nx.draw(gdf_nx)
# momepy.roundabout_simplification(gdf)
```

````{=html}
<!-- Out-takes, to tidy-up/include later:

:::

The graphic below shows a 2 panel plot showing simplification with the `consolidate_intersections` function from the `osmnx` Python package.

::: {#fig-osmnx-consolidate-intersections layout-ncol="2"}
```{python}
#| echo: false
#| eval: false
#| warning: false
import osmnx as ox
# Get all streets within 50 m of Princes Street, Edinburgh:
# Get point that is on Princes Street:
# ox.geocode_to_gdf("Princes Street Edinburgh")
G = ox.graph_from_place("Royal Scots Greys Memorial", network_type="walk", buffer_dist=200)
ox.plot_graph(G);
# Plot the graph in an interactive map:
# ox.plot_graph_folium(G)
# project to 27700

import osmnx as ox
G_projected = ox.project_graph(G, 'EPSG:27700')
# simplify:
G_simplified = ox.consolidate_intersections(G_projected, tolerance=10, rebuild_graph=True)
# plot G_simplified as GeoPandas in Quarto:
ox.plot_graph(G_simplified);
plt.show()
```

Illustration of consolidation of intersections, with the `consolidate_intersections` function from the `osmnx` Python package.
:::

A more aggressive approach is to simplify and alter network topology in a single step, "through the removal of duplicate or parallel edges, and combining simply-connected nodes" [@deakin2023].
Two approaches to this are outlined below. -->
````