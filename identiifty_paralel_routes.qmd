# Prerequisites

To run the code in this repo, you need to have a working Python installation with the following packages installed (with pip in this case):

```{bash}
#| eval: false
pip install shapely geopandas pandas networkx numpy matplotlib rtree scipy osmnx geopy
```
```{python}
from shapely.geometry import MultiLineString, LineString
from shapely.ops import unary_union
import geopandas as gpd
import pandas as pd
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import math
from rtree import index
from scipy.spatial import Voronoi, voronoi_plot_2d
from shapely.geometry import MultiLineString, Polygon, LineString
from shapely.ops import polygonize, unary_union
import osmnx as ox
from geopy.distance import geodesic
import shapely.geometry
from itertools import combinations
from shapely.geometry import Point
import itertools
```

```{python}
gdf = gpd.read_file("data/rnet_princes_street.geojson")
gdf.crs
```

Getting Road infomation form OSM data

```{python}
# Fetch OSM road network data around the centroid of the provided geodataframe.

def fetch_osm_data(gdf, filepath="data/edges.shp"):
    """
    Fetch OSM road network data around the centroid of the provided geodataframe.

    Parameters:
    - gdf (geopandas.GeoDataFrame): The input geodataframe.
    - filepath (str): The path to save the downloaded OSM data.

    Returns:
    - gdf_road (geopandas.GeoDataFrame): The road network data from OSM.
    """
    
    # Calculate centroid and convert to WGS84 (EPSG:4326)
    centroid = gdf.unary_union.centroid
    point = (centroid.y, centroid.x)

    # Compute the bounding box of the geodataframe
    bounds = gdf.total_bounds

    # Calculate the diagonal length of the bounding box in degrees
    diagonal_length_degrees = np.sqrt((bounds[2] - bounds[0])**2 + (bounds[3] - bounds[1])**2)

    # Take half of the diagonal length as the maximum distance in degrees
    max_distance_degrees = diagonal_length_degrees / 2

    # Calculate the distance in meters for max_distance_degrees at the latitude of the centroid
    start_point = (point[0], point[1])
    end_point_max_distance = (point[0], point[1] + max_distance_degrees)

    # Compute the max_distance in meters using geopy
    max_distance_meters = geodesic(start_point, end_point_max_distance).meters

    # Check if the data exists at the specified filepath
    if not os.path.exists(filepath):
        # Download the road network data from OSM
        graph = ox.graph_from_point(point, dist=max_distance_meters, network_type='all')

        # Save the road network data to the specified filepath
        ox.save_graph_shapefile(graph, filepath=filepath)
    
    # Read the road network data as a geodataframe
    gdf_road = gpd.read_file(filepath)

    return gdf_road

gdf_road = fetch_osm_data(gdf, filepath="data/edges.shp")
# gdf_road.explore() 

```


```{python}
   
# Define the buffer size
buffer_size = 0.00002

# Create a buffer around the geometries in gdf
gdf_buffered = gdf.copy()
gdf_buffered.geometry = gdf.geometry.buffer(buffer_size)

# Create a spatial index for gdf_road
sindex = gdf_road.sindex

# Define the intersection length threshold
intersection_length_threshold = 0.00005

# List to store matching lines
matched_rows = []

# Iterate over the buffered geometries in the GeoJSON GeoDataFrame
for geojson_line in gdf_buffered.geometry:
    # Use the spatial index to find potential matches
    possible_matches_index = list(sindex.intersection(geojson_line.bounds))
    possible_matches = gdf_road.iloc[possible_matches_index]
    
    # Filter possible matches to only those that actually intersect
    precise_matches = possible_matches[possible_matches.intersects(geojson_line)]
    
    # Check the intersection length and store rows that match the condition
    for _, edge_row in precise_matches.iterrows():
        shapefile_line = edge_row.geometry
        intersection = geojson_line.intersection(shapefile_line)
        if intersection.length > intersection_length_threshold:
            matched_rows.append(edge_row)

# Convert the matched_rows list to a GeoDataFrame
matching_lines_large_intersection = gpd.GeoDataFrame(matched_rows, columns=gdf_road.columns)

matching_lines_large_intersection.to_file("G:/temp/gdf_matching_lines.geojson", driver='GeoJSON')

gdf = gpd.read_file("G:/temp/gdf_matching_lines.geojson")

list_columns = []

for col in gdf.columns:
    if any(isinstance(val, list) for val in gdf[col]):
        list_columns.append(col)

for col in list_columns:
    gdf[col] = gdf[col].apply(lambda x: ', '.join(x) if isinstance(x, list) else x)

gdf.to_file("G:/temp/gdf_matching_lines.geojson", driver='GeoJSON')
```

```{python}

gdf_matching_lines = gpd.read_file("G:/temp/gdf_matching_lines.geojson")

def find_farthest_points(geom):
    """Find the two farthest points in a MultiLineString or LineString."""
    # Extract all points from the geometry
    if geom.geom_type == 'MultiLineString':
        points = [Point(coords) for linestring in geom.geoms for coords in linestring.coords]
    else:
        points = [Point(coords) for coords in geom.coords]

    # Find the two farthest points
    max_distance = 0
    farthest_pair = (None, None)
    for point1, point2 in combinations(points, 2):
        distance = point1.distance(point2)
        if distance > max_distance:
            max_distance = distance
            farthest_pair = (point1, point2)
    
    return farthest_pair

import networkx as nx

def generate_all_paths(G, start_point, end_point, max_paths=100):
    """Generate all simple paths between start and end points up to a maximum number of paths."""
    # Initialize a counter for the number of paths
    path_count = 0
    
    # Use DFS to generate all paths
    for path in nx.all_simple_paths(G, start_point, end_point):
        yield path
        
        # Increment the path counter
        path_count += 1
        
        # If we've generated the maximum number of paths, stop
        if path_count >= max_paths:
            return

all_road_paths_count = {}

unique_road_names = gdf_matching_lines['name'].unique()

for road_name in unique_road_names:
    road_gdf = gdf_matching_lines[gdf_matching_lines['name'] == road_name]
    
    # Combine all segments into one MultiLineString to find the farthest points
    combined_geom = road_gdf.geometry.unary_union
    
    # Check for valid geometry before processing
    if combined_geom is not None:
        start_point, end_point = find_farthest_points(combined_geom)
        
        # Convert the road segments to a network graph
        G_road = nx.Graph()
        for _, row in road_gdf.iterrows():
            geom = row['geometry']
            for s, e in zip(list(geom.coords[:-1]), list(geom.coords[1:])):
                # Add nodes
                G_road.add_node(s)
                G_road.add_node(e)
                # Add edge
                G_road.add_edge(s, e, weight=Point(s).distance(Point(e)))
        
        # Use the provided function to generate all paths for the road
        paths = list(generate_all_paths(G_road, start_point.coords[0], end_point.coords[0]))
        
        # Store the number of paths for the road
        all_road_paths_count[road_name] = len(paths)

# Filter out roads that have more than one unique path
roads_with_multiple_paths = [road for road, count in all_road_paths_count.items() if count > 1]
multiple_paths_gdf = gdf_matching_lines[gdf_matching_lines['name'].isin(roads_with_multiple_paths)]

# Plot the roads with multiple paths
fig, ax = plt.subplots(figsize=(12, 8))
multiple_paths_gdf.plot(ax=ax, color='red', linewidth=2)
gdf.plot(ax=ax, linewidth=1, edgecolor='lightgrey')
ax.set_title("Roads with More Than One Path")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.grid(True)
plt.show()

# gdf.explore()

```

```{python}
# Extract the specific road data for "York Place"
york_place_gdf = gdf_matching_lines[gdf_matching_lines['name'] == 'York Place']

# Combine all segments into one MultiLineString to find the farthest points
combined_geom = york_place_gdf.geometry.unary_union

# Convert the road segments to a network graph
G_york = nx.Graph()
for _, row in york_place_gdf.iterrows():
    geom = row['geometry']
    for s, e in zip(list(geom.coords[:-1]), list(geom.coords[1:])):
        # Add nodes
        G_york.add_node(s)
        G_york.add_node(e)
        # Add edge
        G_york.add_edge(s, e, weight=shapely.geometry.Point(s).distance(shapely.geometry.Point(e)))

# Extract the coordinates of the nodes
node_coords = [node for node in G_york.nodes()]

# Extract paths for "York Place"
start_point, end_point = find_farthest_points(combined_geom)
york_paths = list(generate_all_paths(G_york, start_point.coords[0], end_point.coords[0]))

# Extracting xs and ys directly from the single path of "York Place"
xs, ys = zip(*york_paths[0])

# Re-plotting with the single path
fig, ax = plt.subplots(figsize=(12, 8))

# Plot the road segments
york_place_gdf.plot(ax=ax, color='blue', linewidth=1.5, label="York Place")

# Plot the nodes and their indices
for idx, (x, y) in enumerate(york_paths[0]):
    ax.scatter(x, y, color='red')
    ax.text(x, y, str(idx), fontsize=12, ha="center", va="bottom")

# Plot the single path
ax.plot(xs, ys, color='green', linestyle='--', linewidth=3)

ax.set_title(f"York Place with 1 Path and Node Indices")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.grid(True)
# plt.legend()
plt.show()

# Extracting the indices of the start and end points of the path
start_idx = york_paths[0].index(start_point.coords[0])
end_idx = york_paths[0].index(end_point.coords[0])
start_idx, end_idx
```

```{python}
# Extract all nodes from the "York Place" segments
york_nodes = []
for _, row in york_place_gdf.iterrows():
    geom = row['geometry']
    for coord in geom.coords:
        if coord not in york_nodes:
            york_nodes.append(coord)

fig, ax = plt.subplots(figsize=(15, 10))

# Plot the road segments
york_place_gdf.plot(ax=ax, color='blue', linewidth=1.5, label="York Place")

# Plot the nodes and their adjusted indices
for idx, (x, y) in enumerate(york_nodes):
    ax.scatter(x, y, color='red')
    ax.text(x + 0.00005, y-0.00005, str(idx), fontsize=8, ha="left", va="center")  # Adjusting horizontal alignment and font size

ax.set_title(f"York Place with Node Indices")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.grid(True)
# plt.legend()
plt.tight_layout()
plt.show()


```
```{python}
# Define a function to check if two lines are parallel, side-by-side, and of similar length, incorporating the new average distance criterion

def check_refined_criteria(idx1, idx2, gdf, length_threshold=10, point_count=1, avg_distance_threshold=10, use_names=True):
    line1 = gdf.loc[idx1, 'geometry']
    line2 = gdf.loc[idx2, 'geometry']
    
    if use_names and 'name' in gdf.columns:
        name1 = gdf.loc[idx1, 'name']
        name2 = gdf.loc[idx2, 'name']
        
        # Check if all elements in potential list are NaN
        is_name1_na = pd.isna(name1).all() if isinstance(name1, (list, np.ndarray)) else pd.isna(name1)
        is_name2_na = pd.isna(name2).all() if isinstance(name2, (list, np.ndarray)) else pd.isna(name2)
        
        if is_name1_na and is_name2_na:
            pass  # both are NaN, so they are considered equal
        elif is_name1_na or is_name2_na:
            return False  # one is NaN and the other isn't
        else:
            # Convert single strings to list for uniformity
            if isinstance(name1, str):
                name1 = [name1]
            if isinstance(name2, str):
                name2 = [name2]
            
            # Compare names
            if set(name1) != set(name2):
                return False
    # Ensure both geometries are LineStrings
    if not (isinstance(line1, shapely.geometry.LineString) and isinstance(line2, shapely.geometry.LineString)):
        return False

    # Check if lines are essentially the same line or connected end-to-end
    if line1.coords[0] == line2.coords[-1] or line1.coords[-1] == line2.coords[0]:
        return False
    if line1.coords[0] == line2.coords[0] or line1.coords[-1] == line2.coords[-1]:
        return False
           
    # Check for similar length
    length1 = line1.length
    length2 = line2.length
    if abs(length1 - length2) > length_threshold:
        return False
    
    # Extract the vectors representing the lines
    x1, y1, x2, y2 = line1.coords[0][0], line1.coords[0][1], line1.coords[-1][0], line1.coords[-1][1]
    vector1 = np.array([x2 - x1, y2 - y1])
    
    x1, y1, x2, y2 = line2.coords[0][0], line2.coords[0][1], line2.coords[-1][0], line2.coords[-1][1]
    vector2 = np.array([x2 - x1, y2 - y1])
    
    # Normalize the vectors
    vector1 = vector1 / np.linalg.norm(vector1)
    vector2 = vector2 / np.linalg.norm(vector2)
    
    # Calculate the angle between the vectors
    angle = np.arccos(np.dot(vector1, vector2))
    
    # Check if the lines are parallel (angle close to 0 or 180 degrees)
    if np.isclose(angle, 0, atol=1e-2) or np.isclose(angle, np.pi, atol=1e-2):
        # Sample equidistant points along each line
        points1 = [line1.interpolate(distance, normalized=True) for distance in np.linspace(0, 1, point_count)]
        points2 = [line2.interpolate(distance, normalized=True) for distance in np.linspace(0, 1, point_count)]
        
        # Calculate the distances between the points on the two lines
        distances = [point1.distance(point2) for point1, point2 in zip(points1, points2)]
        
        # Calculate average distance
        avg_distance = sum(distances) / len(distances)
        
        # Check if the lines remain close along their lengths based on the new average distance threshold
        if avg_distance < avg_distance_threshold:
            return True

    return False

# Initialize the spatial index
spatial_index = gdf.sindex

# Initialize an empty list to store pairs of lines meeting the refined criteria
refined_criteria_lines_efficient = []

# Loop through each line in the GeoDataFrame
for idx1, row1 in gdf.iterrows():
    line1 = row1['geometry']
    
    # Use the spatial index to find candidates that might be side-by-side and parallel
    possible_matches_index = list(spatial_index.intersection(line1.bounds))
    possible_matches = gdf.iloc[possible_matches_index]
    
    for idx2, row2 in possible_matches.iterrows():
        # Skip the line itself
        if idx1 == idx2:
            continue
            
        # Check if the lines meet the refined criteria
        if check_refined_criteria(idx1, idx2, gdf):
            refined_criteria_lines_efficient.append((idx1, idx2))


# Create a new GeoDataFrame containing only the lines meeting the refined criteria
gdf_refined_criteria_efficient = gdf.loc[[idx for pair in refined_criteria_lines_efficient for idx in pair]]

# Plotting the original GeoDataFrame and the lines meeting the refined criteria
fig, ax = plt.subplots(1, 1, figsize=(10, 10))

# Plot all lines in the sample in light grey
gdf.plot(ax=ax, linewidth=1, edgecolor='lightgrey')

# Plot lines meeting the refined criteria in red
gdf_refined_criteria_efficient.plot(ax=ax, linewidth=2, edgecolor='red')

plt.title('Visualization of Lines Meeting Refined Criteria')
plt.xlabel('Longitude')
plt.ylabel('Latitude')

plt.show()
```




```{python}
# Function to interpolate points along a line
def interpolate_points(line, num_points):
    return [line.interpolate(i/float(num_points - 1), normalized=True) for i in range(num_points)]

# Function to generate a centerline between two parallel lines
def generate_centerline(line1, line2, num_points_factor=100):
    # Interpolate points along each line
    num_points = max(len(line1.coords), len(line2.coords)) * num_points_factor
    points1 = interpolate_points(line1, num_points)
    points2 = interpolate_points(line2, num_points)
    
    # Combine all points from the two lines
    all_points = np.vstack([np.array([(p.x, p.y) for p in points1]),
                            np.array([(p.x, p.y) for p in points2])])
    
    # Create a Voronoi diagram from the points
    vor = Voronoi(all_points)
    
    # Identify the indices that separate points from the two lines
    index_split = len(points1)
    
    # Identify the Voronoi edges that are equidistant to points from different lines
    centerline_edges = []
    for pointidx in vor.ridge_points:
        if (pointidx[0] < index_split and pointidx[1] >= index_split) or \
           (pointidx[1] < index_split and pointidx[0] >= index_split):
            centerline_edges.append(pointidx)
    
    # Convert the point indices to coordinates
    centerline_coords = [[vor.points[i] for i in edge] for edge in centerline_edges]
    
    # Create LineString objects from the coordinates
    centerline = [LineString(edge) for edge in centerline_coords]
    
    # Create a GeoDataFrame from the centerline
    centerline_gdf = gpd.GeoDataFrame(geometry=centerline)
    
    return centerline_gdf

# Function to plot the centerline
def plot_centerline(line1, line2, centerline_gdf):
    fig, ax = plt.subplots(figsize=(10, 10))
    
    # Plot the original lines
    gpd.GeoSeries([line1]).plot(ax=ax, color='blue')
    gpd.GeoSeries([line2]).plot(ax=ax, color='blue')
    
    # Calculate the center points of the centerline and plot them
    center_points = centerline_gdf.geometry.centroid
    center_points_gdf = gpd.GeoDataFrame(geometry=center_points)
    center_points_gdf.plot(ax=ax, color='red', markersize=5)
    
    plt.show()

# Function to convert center points to a center line
def points_to_centerline(center_points):
    # Sort the points based on their coordinates to maintain a logical order
    sorted_points = sorted(center_points, key=lambda point: (point.x, point.y))
    # Create a LineString geometry from the sorted points
    center_line = LineString(sorted_points)
    return center_line
```

```{python}
# Initialize an empty GeoDataFrame to store the resulting centerlines and parallel lines
combined_gdf = gpd.GeoDataFrame(columns=['geometry', 'type'])

# Loop through the list of line pairs to generate centerlines and collect parallel lines
for idx1, idx2 in refined_criteria_lines_efficient:
    # Get the LineString geometries for the line pair
    line1 = gdf.loc[idx1, 'geometry']
    line2 = gdf.loc[idx2, 'geometry']
    
    # Generate the centerline GeoDataFrame
    centerline_gdf = generate_centerline(line1, line2)
    
    # Extract the center points of the centerline
    center_points = centerline_gdf.geometry.centroid.tolist()
    
    # Convert the center points to a center line
    center_line = points_to_centerline(center_points)
    
    # Append the center line and parallel lines to the combined GeoDataFrame
    combined_gdf = combined_gdf.append({'geometry': center_line, 'type': 'centerline'}, ignore_index=True)
    combined_gdf = combined_gdf.append({'geometry': line1, 'type': 'parallel_line'}, ignore_index=True)
    combined_gdf = combined_gdf.append({'geometry': line2, 'type': 'parallel_line'}, ignore_index=True)

# Plot the combined GeoDataFrame with different colors for centerlines and parallel lines
# fig, ax = plt.subplots(figsize=(12, 12))
# combined_gdf[combined_gdf['type'] == 'centerline'].plot(ax=ax, color='green', linewidth=2, label='Centerline')
# combined_gdf[combined_gdf['type'] == 'parallel_line'].plot(ax=ax, color='blue', linewidth=1, label='Parallel Lines')
# plt.title('Centerlines and Parallel Lines')
# plt.xlabel('Longitude')
# plt.ylabel('Latitude')
# plt.legend()
# plt.show()

```

```{python}
import folium

# Function to convert GeoDataFrame to GeoJSON format
def gdf_to_geojson(gdf, properties):
    geojson = {'type':'FeatureCollection', 'features':[]}
    for _, row in gdf.iterrows():
        feature = {'type':'Feature',
                   'properties':{},
                   'geometry':{'type':'LineString',
                               'coordinates':[]}}
        feature['geometry']['coordinates'] = [list(point) for point in list(row['geometry'].coords)]
        for prop in properties:
            feature['properties'][prop] = row[prop]
        geojson['features'].append(feature)
    return geojson

# Initialize a map centered around the coordinates
m = folium.Map([55.952227 , -3.1959271], zoom_start=14)

# Convert the GeoDataFrames to GeoJSON
geojson_centerlines = gdf_to_geojson(combined_gdf[combined_gdf['type'] == 'centerline'], ['type'])
geojson_parallel_lines = gdf_to_geojson(combined_gdf[combined_gdf['type'] == 'parallel_line'], ['type'])

# Add the GeoJSONs to the map
folium.GeoJson(geojson_centerlines, 
               name='Centerlines',
               style_function=lambda x: {'color':'green', 'weight':3}).add_to(m)
folium.GeoJson(geojson_parallel_lines, 
               name='Parallel Lines',
               style_function=lambda x: {'color':'blue', 'weight':4}).add_to(m)

# Add a layer control to toggle between layers
folium.LayerControl().add_to(m)

# Display the map
m

```
