[
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render paper.qmd\nInstall the dependencies by cloning the repository and running the following:\nrequirements_txt = readLines(\"requirements.txt\")\npy_install(requirements_txt, pip = TRUE)\n\n\nLinking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE\n\n\nBreaking News: tmap 3.x is retiring. Please test v4, e.g. with\nremotes::install_github('r-tmap/tmap')\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\ntmap mode set to plotting\n\n\nTo contribute to the papers written as quarto documents (with .qmd extensions) like this one, we recommend using the Quarto extension for VS Code. You can go into the visual editor with the following shortcut:\nCtrl+Shift+F4\nYou can then add citations with Ctrl+Shift+F11 and benefit from Quarto’s other features for academic writing."
  },
  {
    "objectID": "paper.html#simplifying-the-geometry",
    "href": "paper.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 3, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\nThe graphic below shows a 2 panel plot showing simplification with the consolidate_intersections function from the osmnx Python package.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Illustration of consolidation of intersections, with the consolidate_intersections function from the osmnx Python package.\n\n\nA more aggressive approach is to simplify and alter network topology in a single step, “through the removal of duplicate or parallel edges, and combining simply-connected nodes” (Deakin 2023). Two approaches to this are outlined below.\n\n\n4.1.2 Network Simplification\nThe paper presents two approaches for network simplification: one involves image skeletonization, while the other utilizes Voronoi diagrams to identify central lines. The detailed steps of the methodology will be presented in the following sections.\n\n\n4.1.3 Create a projected combined buffered geometry:\nIn both approaches, the network simplification process initiates with the generation of buffered geometries, achieved using the get_geometry_buffer function. A buffer size of 8 meters is selected for this purpose. These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.\nThe street network that requires simplification and the corresponding buffered network are presented as follows:\n\n\n\n\n\n\n\n\n\nFigure 5: Buffered Network Visualization of Edinburgh’s Princes Street\n\n\n\n\n4.1.4 Skeletonization\nThe buffered lines are merged to create a raster image, which is then subjected to a thinning process to yield a skeletal remnant. This remnant retains both the extent and connectivity of the original network, centered around a line that aligns with the combined buffered region. This process is demonstrated using the Sample Street Network.\n\n4.1.4.1 Establish an affine transformation that maps the points within the buffered geometry to corresponding positions in the raster image\nA scaled affine transformation is calculated to align the projected coordinate geometry with the corresponding scaled raster image.\n\n\n\n4.1.5 Affine transforms\nThe affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0. The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation.\n\n4.1.5.1 Rasterio transform\n\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0.5 |  0   | 324166 |\n| 0   | -0.5 | 674527 |\n| 0   |  0   |      1 |\n\n\n\n\n4.1.5.2 Shapely transform\n\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0   | -0.5 | 324166 |\n| 0.5 |  0   | 674527 |\n\n\nIn these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation. The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image. This transformation adjusts the geometry to match the raster’s scale and orientation. Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles. This step ensures a more coherent and accurate representation in the raster image.\n\n\n\n\n\nThe image undergoes a thinning process, yielding a skeletal raster image as the result. This skeletonized image effectively captures the essential structure and layout of the original network.\n\n\n\n\n\nThe rasterized skeletal image is then converted back into point geometry, completing the transformation process.\n\n\n\n\n\nThe challenge with this approach is that instead of generating points situated on the simplified network, it yields a mere set of points. What is required for effective analysis is a simplified set of line geometries, not just isolated points. This necessitates the inference of line geometry from the associated set of points.\n\n\n4.1.7 Transforming point geometry into line geometry\nTransforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.\nThe process of transforming point geometry into line geometry involves several key steps. Initially, the point set, derived from a skeletonized image, is analysed to identify adjacent points. Adjacency is determined based on proximity within the raster coordinate system, usually within a 1x1 pixel square.\nOnce adjacent points are identified, line segments are created by connecting these points. The final and crucial step is the amalgamation of these individual line segments. This combination results in a continuous line geometry that represents the simplified network structure. This conversion from point to line geometry is a pivotal aspect of network simplification.\nTo visualize the simplified network in its original spatial context, it is necessary to apply the reverse affine transformation. This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework.\n\n\n\n\n\n\n\n4.1.8 Knots\nKnots in the network often manifest as multiple short segments at intersections, resembling tangled knots.\nTo address these, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context.\n\n\n\n\n\n\n\n4.1.9 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points."
  },
  {
    "objectID": "paper.html#simplification-via-voronoi-polygons",
    "href": "paper.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach,the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a center-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n4.2.1 Boundary\nThe get_geometry_line funtion is defined to convert a given geometry into a simplified LineString boundary. The function first extracts the boundary of the input geometry and then simplifies it using a set tolerance level. The result is a GeoSeries of the simplified LineString, correctly aligned with a specified coordinate reference system (CRS). This functionality is particularly useful in geographic information systems (GIS) for delineating and visualizing precise boundaries of spatial objects. The code demonstrates its utility by applying the function to a geometry (nx_geometry) and visualizing the resultant simplified boundaries (nx_boundary), highlighting its practical application in spatial analysis and network simplification.\n\n\n\n\n\n\n\n4.2.2 Segment\nThe simplified LineString geometries are then broken down into shorter segments.\n\n\n\n\n\n\n\n4.2.3 Point\nThe simplified LineString geometries are converted into point geometries.\n\n\n\n\n\n\n\n4.2.4 Voronoi\nThe Voronoi diagram is generated from nx_point within the bounds of nx_envelope.\n\n\n\n\n\n\n\n4.2.5 Voronoi 2\n\n\n\n\n\n\n\n4.2.6 Voronoi simplified network\n\n\n\n\n\n\n\n4.2.7 Voronoi line\n\n\n\n\n\n\n\n4.2.8 Primal network"
  },
  {
    "objectID": "paper.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "href": "paper.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Integrating attributes from the detailed network into the simplified network",
    "text": "4.3 Integrating attributes from the detailed network into the simplified network\nIn instances where a simplified version of the network is readily available, such as OS Open Roads, the steps for network simplification can be bypassed. Instead, the focus shifts to integrating attributes from the detailed network into the simplified network. This approach streamlines the process, leveraging pre-existing simplified network data while enriching it with detailed attributes."
  },
  {
    "objectID": "paper.html#footnotes",
    "href": "paper.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "This website hosts the networkmerge paper, results of which are publicly available at https://npt.scot. It was produced with Quarto, which was also used to support the academic paper shown below. See https://quarto.org/docs/websites for further information.\nThe paper is re-built automatically when the source code is updated:\nSee github.com/nptscot/networkmerge for the source code underlying this website."
  },
  {
    "objectID": "index.html#simplifying-the-geometry",
    "href": "index.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 3, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 3.\n\n\n\n\ninput = sf::read_sf('data/minimal-input.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\")\nsimplification_levels = c(1, 0.5, 0.1, 0.001)\n# ordered factor of simplification levels:\nsimplification_df = data.frame(\n  id = as.character(1:length(simplification_levels)),\n  simp_factor = simplification_levels,\n  keep = paste0(\"Keep: \", round(as.numeric(simplification_levels) * 100, 2), \"%\")\n  )\nsimplification_df$keep = ordered(simplification_df$keep, levels = simplification_df$keep)\n\nsmplfy = function(x_list, keep) {\n  x_list = lapply(\n    keep,\n    function(x) {\n      res = rmapshaper::ms_simplify(x_list, keep_shapes = TRUE, keep = x)\n      res$id = x\n      res\n    }\n    )\n  do.call(rbind, x_list)\n}\n# input_simplified = smplfy(input_projected, simplification_levels)\n# sf::write_sf(input_simplified, \"data/input_simplified1.geojson\")\ninput_simplified = sf::read_sf('data/input_simplified1.geojson')\ninput_simplified = left_join(\n  input_simplified,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\nm = tm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE) \n\nm\n\n\n\n\n\n\n\ninput = sf::read_sf('data/rnet_princes_street_minimal.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\")\n# input_simplified = smplfy(input_projected, simplification_levels)\n# sf::write_sf(input_simplified, \"data/input_simplified2.geojson\", delete_dsn = TRUE)\ninput_simplified2 = sf::read_sf('data/input_simplified2.geojson')\ninput_simplified = left_join(\n  input_simplified2,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\ntm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE) \n\n\n\n\n\nFigure 3: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\nThe graphic below shows a 2 panel plot showing simplification with the consolidate_intersections function from the osmnx Python package.\n\n\n\n\nimport osmnx as ox\n# Get all streets within 50 m of Princes Street, Edinburgh:\n# Get point that is on Princes Street:\n# ox.geocode_to_gdf(\"Princes Street Edinburgh\")\nG = ox.graph_from_place(\"Royal Scots Greys Memorial\", network_type=\"walk\", buffer_dist=200)\nox.plot_graph(G);\n\n\n\n# Plot the graph in an interactive map:\n# ox.plot_graph_folium(G)\n# project to 27700\n\n\nimport osmnx as ox\nG_projected = ox.project_graph(G, 'EPSG:27700')\n# simplify:\nG_simplified = ox.consolidate_intersections(G_projected, tolerance=10, rebuild_graph=True)\n# plot G_simplified as GeoPandas in Quarto:\nox.plot_graph(G_simplified);\n\n\n\n\n\nFigure 4: Illustration of consolidation of intersections, with the consolidate_intersections function from the osmnx Python package.\n\n\nA more aggressive approach is to simplify and alter network topology in a single step, “through the removal of duplicate or parallel edges, and combining simply-connected nodes” (Deakin 2023). Two approaches to this are outlined below.\n\n\n4.1.2 Network Simplification\nThe paper presents two approaches for network simplification: one involves image skeletonization, while the other utilizes Voronoi diagrams to identify central lines. The detailed steps of the methodology will be presented in the following sections.\n\n\n4.1.3 Create a projected combined buffered geometry:\nIn both approaches, the network simplification process initiates with the generation of buffered geometries, achieved using the get_geometry_buffer function. A buffer size of 8 meters is selected for this purpose. These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.\n\nfrom functools import partial\nfrom shapely import box\nfrom shapely.ops import voronoi_diagram\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely import get_coordinates, line_merge, set_precision, unary_union\nfrom shapely.geometry import MultiPoint,MultiLineString,LineString,Point\nimport pandas as pd\nimport numpy as np\nplt.rcParams[\"figure.figsize\"] = (12, 12)\n\ndef get_geometry_buffer(this_gf, radius=8.0):\n    \"\"\"get_geometry_buffer: return radius buffered GeoDataFrame\n\n    args:\n      this_gf: GeoDataFrame to\n      radius: (default value = 8.0)\n\n    returns:\n      buffered GeoSeries geometry\n\n    \"\"\"\n    r = gp.GeoSeries(this_gf, crs=CRS).buffer(radius, join_style=\"round\", cap_style=\"round\")\n    union = unary_union(r)\n    try:\n        r = gp.GeoSeries(union.geoms, crs=CRS)\n    except AttributeError:\n        r = gp.GeoSeries(union, crs=CRS)\n    return r\n\nCRS = \"EPSG:27700\"\nbuffer_size = 8.0\n\nset_precision_pointone = partial(set_precision, grid_size=0.1)\nbase_nx = gp.read_file(\"https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson\").to_crs(CRS)\nbase_nx[\"geometry\"] = base_nx[\"geometry\"].map(set_precision_pointone)\nnx_geometry = get_geometry_buffer(base_nx[\"geometry\"], radius=buffer_size)\n\nThe street network that requires simplification and the corresponding buffered network are presented as follows:\n\n\n\n\nfig, axs = plt.subplots(1, 2, figsize=(12, 6))\n\n# Plotting the base network on the first subplot\naxs[0].set_title(\"Sample Street Network - Edinburgh's Princes Street\")\nbase_nx.plot(ax=axs[0], edgecolor=\"blue\", color=\"blue\")\naxs[0].grid()\n\n# Plotting the buffered network on the second subplot\naxs[1].set_title(\"Buffered Network of Edinburgh's Princes Street\")\nnx_geometry.plot(ax=axs[1], edgecolor=\"black\", color=\"blue\")\naxs[1].grid()\n\nplt.show()\n\n\n\n\n\nFigure 5: Buffered Network Visualization of Edinburgh’s Princes Street\n\n\n\n\n4.1.4 Skeletonization\nThe buffered lines are merged to create a raster image, which is then subjected to a thinning process to yield a skeletal remnant. This remnant retains both the extent and connectivity of the original network, centered around a line that aligns with the combined buffered region. This process is demonstrated using the Sample Street Network.\n\n4.1.4.1 Establish an affine transformation that maps the points within the buffered geometry to corresponding positions in the raster image\nA scaled affine transformation is calculated to align the projected coordinate geometry with the corresponding scaled raster image.\n\nimport numpy as np\nimport pandas as pd\nimport rasterio as rio\nimport rasterio.features as rif\n\ndef get_pxsize(bound, scale=1.0):\n    \"\"\"get_pxsize: calculates scaled image size in px\n\n      bound: boundary corner points\n      scale: scaling factor (default = 1.0)\n\n    returns:\n      size in px\n\n    \"\"\"\n    r = np.diff(bound.reshape(-1, 2), axis=0)\n    r = np.ceil(r.reshape(-1))\n    return (r[[1, 0]] * scale).astype(int)\n\n\ndef get_affine_transform(this_gf, scale=1.0):\n    \"\"\"get_affine_transform: return affine transformations matrices, and scaled image size\n    from GeoPandas boundary size\n\n      this_gf: GeoPanda\n      scale:  (default = 1.0)\n\n    returns:\n      rasterio and shapely affine tranformation matrices, and image size in px\n\n    \"\"\"\n    TRANSFORM_ONE = np.asarray([0.0, 1.0, -1.0, 0.0, 1.0, 1.0])\n    bound = this_gf.total_bounds\n    s = TRANSFORM_ONE / scale\n    s[[4, 5]] = bound[[0, 3]]\n    r = s[[1, 0, 4, 3, 2, 5]]\n    r = rio.Affine(*r)\n    return r, s, get_pxsize(bound, scale)\n\nr_matrix, s_matrix, out_shape = get_affine_transform(nx_geometry, scale=2.0)\n\n\n\n\n4.1.5 Affine transforms\nThe affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0. The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation.\n\n4.1.5.1 Rasterio transform\n\nfrom IPython.display import display, Markdown\ndef display_matrix(matrix, header):\n    r = matrix.to_markdown(index=False, headers=header)\n    display(r)\n\nor_matrix = pd.DataFrame(np.asarray(r_matrix).reshape(-1, 3))\nos_matrix = pd.DataFrame(np.asarray(s_matrix).reshape(3, -1).T)\ndisplay_matrix(or_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0.5 |  0   | 324166 |\n| 0   | -0.5 | 674527 |\n| 0   |  0   |      1 |\n\n\n\n\n4.1.5.2 Shapely transform\n\ndisplay_matrix(os_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0   | -0.5 | 324166 |\n| 0.5 |  0   | 674527 |\n\n\nIn these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation. The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image. This transformation adjusts the geometry to match the raster’s scale and orientation. Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles. This step ensures a more coherent and accurate representation in the raster image.\n\nimport warnings\n\nfrom skimage.morphology import remove_small_holes, skeletonize\nfrom shapely.affinity import affine_transform\nfrom shapely.geometry import Point\nimport rasterio.plot as rip\n\ngeometry_im = rif.rasterize(nx_geometry.values, transform=r_matrix, out_shape=out_shape)\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    geometry_im = remove_small_holes(geometry_im, 20).astype(np.uint8)\n\nrip.show(geometry_im, cmap=\"Blues\", title=\"buffer geometry\")\n\n\n\n\nThe image undergoes a thinning process, yielding a skeletal raster image as the result. This skeletonized image effectively captures the essential structure and layout of the original network.\n\nskeleton_im = skeletonize(geometry_im).astype(np.uint8)\npoint_im = np.stack(np.where(skeleton_im &gt;= 1))\nrip.show(skeleton_im, cmap=\"Blues\", title=\"skeleton geometry\")\n\n\n\nnx_point = gp.GeoSeries(map(Point, point_im.T), crs=CRS)\n\nThe rasterized skeletal image is then converted back into point geometry, completing the transformation process.\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\ntransform_point = nx_point.map(shapely_transform).map(set_precision_pointone)\ntransform_point.plot(edgecolor=\"black\", color=\"blue\").grid()\nplt.show()\n\n\n\n\nThe challenge with this approach is that instead of generating points situated on the simplified network, it yields a mere set of points. What is required for effective analysis is a simplified set of line geometries, not just isolated points. This necessitates the inference of line geometry from the associated set of points.\n\n\n4.1.7 Transforming point geometry into line geometry\nTransforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.\nThe process of transforming point geometry into line geometry involves several key steps. Initially, the point set, derived from a skeletonized image, is analysed to identify adjacent points. Adjacency is determined based on proximity within the raster coordinate system, usually within a 1x1 pixel square.\nOnce adjacent points are identified, line segments are created by connecting these points. The final and crucial step is the amalgamation of these individual line segments. This combination results in a continuous line geometry that represents the simplified network structure. This conversion from point to line geometry is a pivotal aspect of network simplification.\n\nfrom shapely import get_coordinates\nfrom shapely.geometry import LineString, MultiLineString\n\ndef get_raster_line_with_knots(point):\n    \"\"\"get_raster_line_with_knots: return LineString GeoSeries from 1px line points with knots\n\n    args:\n      point: 1px point GeoSeries array with knots\n\n    returns:\n      1px line LineString GeoSeries with knots removed\n\n    \"\"\"\n    square = point.buffer(1, cap_style=\"square\", mitre_limit=1)\n    ix = point.sindex.query(square, predicate=\"covers\").T\n    ix = np.sort(ix)\n    s = pd.DataFrame(ix).drop_duplicates().reset_index(drop=True)\n    s = s.loc[np.where(s[0] != s[1])]\n    s = np.stack([point[s[0].values], point[s[1].values]]).T\n    r = gp.GeoSeries(map(LineString, s), crs=CRS)\n    edge, node = get_source_target(combine_line(r).to_frame(\"geometry\"))\n    return combine_line(edge[\"geometry\"])\n\ndef get_end(geometry):\n    \"\"\"get_end: return numpy array of geometry LineString end-points\n\n    args:\n      geometry: geometry LineString\n\n    returns:\n      end-point numpy arrays\n\n    \"\"\"\n    r = get_coordinates(geometry)\n    return np.vstack((r[0, :], r[-1, :]))\n\ndef get_source_target(line):\n    \"\"\"get_source_target: return edge and node GeoDataFrames from LineString with unique\n    node Point and edge source and target\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node: GeoDataFrames\n\n    \"\"\"\n    edge = line.copy()\n    r = edge[\"geometry\"].map(get_end)\n    r = np.stack(r)\n    node = gp.GeoSeries(map(Point, r.reshape(-1, 2)), crs=CRS).to_frame(\"geometry\")\n    count = node.groupby(\"geometry\").size().rename(\"count\")\n    node = node.drop_duplicates(\"geometry\").set_index(\"geometry\", drop=False)\n    node = node.join(count).reset_index(drop=True).reset_index(names=\"node\")\n    ix = node.set_index(\"geometry\")[\"node\"]\n    edge = edge.reset_index(names=\"edge\")\n    edge[\"source\"] = ix.loc[map(Point, r[:, 0])].values\n    edge[\"target\"] = ix.loc[map(Point, r[:, 1])].values\n    return edge, node\n\ndef combine_line(line):\n    \"\"\"combine_line: return LineString GeoSeries combining lines with intersecting endpoints\n\n    args:\n      line: mixed LineString GeoSeries\n\n    returns:\n      join LineString GeoSeries\n\n    \"\"\"\n    r = MultiLineString(line.values)\n    return gp.GeoSeries(line_merge(r).geoms, crs=CRS)\n\nnx_line = get_raster_line_with_knots(nx_point)\n\nTo visualize the simplified network in its original spatial context, it is necessary to apply the reverse affine transformation. This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework.\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.8 Knots\nKnots in the network often manifest as multiple short segments at intersections, resembling tangled knots.\nTo address these, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context.\n\nimport networkx as nx\nfrom shapely.geometry import MultiPoint\n\ndef get_raster_line_without_knot(this_line):\n    \"\"\"get_raster_line_without_knot: remove knots from LineString GeoSeries\n\n    args:\n      this_line: LineString GeoSeries array with knots\n\n    returns:\n      LineString GeoSeries with knots removed\n\n    \"\"\"\n    edge, node = get_source_target(this_line)\n    ix = edge.length &gt; 2.0\n    connected = get_connected_class(edge.loc[~ix, [\"source\", \"target\"]])\n    node = node.loc[connected.index].join(connected).sort_index()\n    connected_edge = get_centre(node)\n    r = combine_line(pd.concat([connected_edge[\"geometry\"], edge.loc[ix, \"geometry\"]]))\n    return r[r.length &gt; 2.0]\n\n\ndef get_connected_class(edge):\n    \"\"\"get_connected_class: return labeled connected node pandas Series from edge list\n\n    args:\n      edge_list: source, target edge pandas DataFrame\n\n    returns:\n      labeled node pandas Series\n\n    \"\"\"\n    nx_graph = nx.from_pandas_edgelist(edge)\n    connected = nx.connected_components(nx_graph)\n    r = {k: i for i, j in enumerate(connected) for k in j}\n    return pd.Series(r, name=\"class\")\n\ndef get_centre(node):\n    \"\"\"get_centre_edge: return centroid Point from discrete node clusters\n\n    args:\n      node: discrete node cluster GeoDataSeries\n\n    returns:\n      GeoDataCentre node cluster centroid Point\n\n    \"\"\"\n    centre = node[[\"geometry\", \"class\"]].groupby(\"class\").aggregate(tuple)\n    centre = gp.GeoSeries(centre[\"geometry\"].map(MultiPoint), crs=CRS).centroid\n    centre = centre.rename(\"target\")\n    geometry = node[[\"class\", \"geometry\"]].set_index(\"class\").join(centre)\n    geometry = geometry.apply(LineString, axis=1)\n    r = node.rename(columns={\"node\": \"source\"}).copy()\n    r[\"geometry\"] = geometry.values\n    return r\n\n\nnx_line = get_raster_line_without_knot(nx_line.to_frame(\"geometry\"))\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.9 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points.\n\ndef get_nx(line):\n    \"\"\"get_nx: return primal edge and node network from LineString GeoDataFrame\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node GeoDataFrames\n\n    \"\"\"\n    r = line.map(get_end)\n    edge = gp.GeoSeries(r.map(LineString), crs=CRS)\n    r = np.vstack(r.to_numpy())\n    r = gp.GeoSeries(map(Point, r)).to_frame(\"geometry\")\n    r = r.groupby(r.columns.to_list(), as_index=False).size()\n    return edge\n\n\nnx_edge = get_nx(nx_line)\nnx_output = nx_edge.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#simplification-via-voronoi-polygons",
    "href": "index.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach,the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a center-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n4.2.1 Boundary\nThe get_geometry_line funtion is defined to convert a given geometry into a simplified LineString boundary. The function first extracts the boundary of the input geometry and then simplifies it using a set tolerance level. The result is a GeoSeries of the simplified LineString, correctly aligned with a specified coordinate reference system (CRS). This functionality is particularly useful in geographic information systems (GIS) for delineating and visualizing precise boundaries of spatial objects. The code demonstrates its utility by applying the function to a geometry (nx_geometry) and visualizing the resultant simplified boundaries (nx_boundary), highlighting its practical application in spatial analysis and network simplification.\n\nfrom shapely import box\nfrom shapely.ops import voronoi_diagram\n\nscale = 5.0\ntolerance=1.0\n\ndef get_geometry_line(this_buffer):\n    \"\"\"get_geometry_line: returns LineString boundary from geometry\n\n    args:\n      this_buffer: geometry to find LineString\n\n    returns:\n       simplified LineString boundary\n    \"\"\"\n    r = this_buffer.boundary.explode(index_parts=False).reset_index(drop=True)\n    return gp.GeoSeries(r.simplify(tolerance=0.5), crs=CRS)\n\nnx_boundary = get_geometry_line(nx_geometry)\nnx_boundary.plot()\nplt.show()\n\n\n\n\n\n\n4.2.2 Segment\nThe simplified LineString geometries are then broken down into shorter segments.\n\ndef get_segment_nx(line, scale):\n    \"\"\"get_segment_nx: segment line into sections, no more than scale long\n\n    args:\n      line:  line to segment\n      scale: length to segment line\n\n    returns:\n      segmented LineStrings\n\n    \"\"\"\n    set_segment = partial(get_segment, distance=scale)\n    r = line.map(set_segment).explode().rename(\"geometry\")\n    return gp.GeoDataFrame(r, crs=CRS)\n\ndef get_linestring(line):\n    \"\"\"get_linestring: return LineString GeoSeries from line coordinates\n\n    args:\n      line:\n\n    returns:\n       LineString GeoSeries\n    \"\"\"\n    r = get_coordinates(line)\n    r = np.stack([gp.points_from_xy(*r[:-1].T), gp.points_from_xy(*r[1:].T)])\n    return gp.GeoSeries(pd.DataFrame(r.T).apply(LineString, axis=1), crs=CRS).values\n\ndef get_segment(line, distance=50.0):\n    \"\"\"get_segment: segment LineString GeoSeries into distance length segments\n\n    args:\n      line: GeoSeries LineString\n      length: segmentation distance (default value = 50.0)\n\n    returns:\n      GeoSeries of LineStrings of up to length distance\n\n    \"\"\"\n    return get_linestring(line.segmentize(distance))\n\nnx_segment = get_segment_nx(nx_boundary, scale).reset_index(drop=True)\nnx_segment.plot(edgecolor=\"red\", linestyle='--', linewidth=1)\nplt.show()\n\n\n\n\n\n\n4.2.3 Point\nThe simplified LineString geometries are converted into point geometries.\n\nnx_point = nx_segment.loc[:, \"geometry\"].map(get_coordinates).explode()\nnx_point = MultiPoint(nx_point[::2].map(Point).values)\nnx_output = gp.GeoSeries(nx_point, crs=CRS)\nnx_output.plot(edgecolor=\"blue\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n4.2.4 Voronoi\nThe Voronoi diagram is generated from nx_point within the bounds of nx_envelope.\n\nnx_envelope = box(*nx_point.bounds)\nnx_voronoi = voronoi_diagram(nx_point, envelope=nx_envelope, tolerance=tolerance, edges=True)\nnx_voronoi = gp.GeoSeries(map(set_precision_pointone, nx_voronoi.geoms), crs=CRS)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.5 Voronoi 2\n\nnx_voronoi = nx_voronoi.explode(index_parts=False).clip(nx_envelope)\nix = ~nx_voronoi.is_empty & (nx_voronoi.type == \"LineString\")\nnx_voronoi = nx_voronoi[ix].reset_index(drop=True)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.6 Voronoi simplified network\n\ndef get_voronoi_line(voronoi, boundary, geometry, buffer_size):\n    \"\"\"get_voronoi_line: returns cleaned simplified line by filtering Voronoi lines by distance,\n    contained within network buffer Polygons, and combining overlapping end-points\n\n    args:\n      voronoi:     Voronoi LineString\n      boundary:    network buffer LineString\n      geometry:    network buffer Polygon\n      buffer_size: network buffer distance [m]\n\n    returns:\n      simplified simplified network line\n\n    \"\"\"\n    offset = buffer_size / 2.0\n    r = filter_distance(voronoi, boundary, offset)\n    r = filter_buffer(r, geometry)\n    edge, node = get_source_target(r.to_frame(\"geometry\"))\n    ix = node[\"count\"] &lt; 4\n    square = node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\n    square = gp.GeoSeries(unary_union(square.values).geoms, crs=CRS)\n    r = edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\n    r = set_geometry(r, square)\n    return combine_line(r)\n\ndef filter_distance(line, boundary, offset):\n    \"\"\"filter_distance: filter line closer than distance offset from boundary\n\n    args:\n      line:     LineStrings to simplify\n      boundary: boundary LineString\n      offset:\n\n    returns:\n      simplified LineStrings\n    \"\"\"\n    edge, _ = get_source_target(line.to_frame(\"geometry\"))\n    (ix, _), distance = boundary.sindex.nearest(edge[\"geometry\"], return_distance=True)\n    _, ix = np.unique(ix, return_index=True)\n    ix = distance[ix] &gt; offset\n    return combine_line(edge.loc[ix, \"geometry\"]).simplify(1.0)\n\ndef filter_buffer(line, geometry):\n    \"\"\"filter_buffer: filter keeping lines within boundary Polygon\n\n    args:\n      line:     LineStrings to simplify\n      geometry: boundary Polygon\n\n    returns:\n      filtered LineStrings\n    \"\"\"\n    (_, ix) = line.sindex.query(geometry, predicate=\"contains_properly\")\n    return combine_line(line.loc[ix]).simplify(1.0)\n\ndef set_geometry(line, square):\n    \"\"\"set_geometry: return LineString simplified by combining overlapping end-points\n\n    args:\n      line:     LineStrings to simplify\n      square:   overlapping squares\n\n    returns:\n      simplified LineStrings\n\n    \"\"\"\n    r = line.reset_index(drop=True)\n    centroid = square.centroid.map(set_precision_pointone).set_crs(CRS)\n    edge, node = get_source_target(r)\n    ix = node[\"geometry\"].sindex.query(square, predicate=\"contains_properly\")\n    node.loc[ix[1], \"geometry\"] = centroid[ix[0]].values\n    source = node.loc[edge[\"source\"], \"geometry\"].values\n    target = node.loc[edge[\"target\"], \"geometry\"].values\n    r = np.stack([source, target]).T\n    return gp.GeoSeries(map(LineString, r), crs=CRS)\n\n#nx_line = get_voronoi_line(nx_voronoi, nx_boundary, nx_geometry, buffer_size)\n\noffset = buffer_size / 2.0\nnx_line = filter_distance(nx_voronoi, nx_boundary, offset)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.7 Voronoi line\n\nnx_line = filter_buffer(nx_line, nx_geometry)\nnx_edge, nx_node = get_source_target(nx_line.to_frame(\"geometry\"))\nix = nx_node[\"count\"] &lt; 4\nnx_square = nx_node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\nnx_square = gp.GeoSeries(unary_union(nx_square.values).geoms, crs=CRS)\nnx_line = nx_edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\nnx_line = set_geometry(nx_line, nx_square)\nnx_line = combine_line(nx_line)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.8 Primal network\n\nnx_edge = get_nx(nx_line)\nnx_edge.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "href": "index.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Integrating attributes from the detailed network into the simplified network",
    "text": "4.3 Integrating attributes from the detailed network into the simplified network\nIn instances where a simplified version of the network is readily available, such as OS Open Roads, the steps for network simplification can be bypassed. Instead, the focus shifts to integrating attributes from the detailed network into the simplified network. This approach streamlines the process, leveraging pre-existing simplified network data while enriching it with detailed attributes."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  }
]