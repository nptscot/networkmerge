[
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render paper.qmd\nInstall the dependencies by cloning the repository and running the following:\nrequirements_txt = readLines(\"requirements.txt\")\npy_install(requirements_txt, pip = TRUE)\nTo contribute to the papers written as quarto documents (with .qmd extensions) like this one, we recommend using the Quarto extension for VS Code. You can go into the visual editor with the following shortcut:\nCtrl+Shift+F4\nYou can then add citations with Ctrl+Shift+F11 and benefit from Quarto’s other features for academic writing."
  },
  {
    "objectID": "paper.html#simplifying-the-geometry",
    "href": "paper.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 3, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 3.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\nThe graphic below shows a 2 panel plot showing simplification with the consolidate_intersections function from the osmnx Python package.\n\n\n\n\n\n\n\n\n\n\nFigure 4: Illustration of consolidation of intersections, with the consolidate_intersections function from the osmnx Python package.\n\n\nA more aggressive approach is to simplify and alter network topology in a single step, “through the removal of duplicate or parallel edges, and combining simply-connected nodes” (Deakin 2023). Two approaches to this are outlined below.\n\n\n4.1.2 Network Simplification\nThere are two simplification approaches based presented either using image skeletonization or Voronoi diagram to finding a centre line.\n\n\n4.1.3 Create a projected combined buffered geometry:\nBoth approaches a buffer, in this case 8.0m, is applied to the base network lines.\nThe buffered street network to be simplified is\n\n\n\nEdinburgh Princes Street buffer network\n\n\n\n\n\n4.1.4 Skeletonization\nBuffered lines are combined to form a raster image and thinned to produce to a skeletal remnant that preserves the extent and connectivity centred on a line centred on the combined buffered region, using the Edinburgh GeoJSON network as above.\n\n4.1.4.1 Create the affine transformation between the points in the buffer and raster image\nA scaled affine transformations between the projected coordinate geometry and scaled raster image is calculated.\n\n\n\n4.1.5 Affine transforms\n\n4.1.5.1 Rasterio transform\n\n\n4.1.5.2 Shapely transform\nIn this example a scale factor of 2.0 is used.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to the projected coordinate geometry to create a scaled raster image. The raster image is then cleaned to remove small holes in the image, typically where buffer lines run parallel or intersect at shallow angles.\nThe image is then thinned and the resulting giving skeleton raster image.\nThe point geometry can then be transformed back to a point geometry.\nThe issue with this is that rather than points that lie on the simplified network, we need a simplified set of lines not a set. This requires the line geometry to be inferred from associated points.\n\n\n4.1.7 Conversion from point to line geometry\nCreating a simplified line geometry from a skeletonized point set is arguably the most awkward step in creating a simplified network.\nFirst identify all adjacent points, which are points within a 1x1 px square in the raster coordinate system. Then create line segments from lines between all adjacent points, and finally combine and the resultant lines geometries.\nTo see the simplified network requires the reverse affine transformation to be applied,\n\n\n4.1.8 Knots\nWhere lines intersect multiple short segment may occur which look like knots.\nTo remove these these short segments are clustered, a cluster centre-point calculated, end-points of longer-lines connected to the segment cluser are then moved to cluster centre-point, removing the knot. As before, prior to plotting the simplified network the reverse affine transformation is applied,\n\n\n4.1.9 Primal network\nThere are circumstances where it may useful to see a “primal” network, that only consists of lines from start and end points,"
  },
  {
    "objectID": "paper.html#simplification-via-voronoi-polygons",
    "href": "paper.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach lines are buffered, the buffer edges segmented into sequences of points and a centre-line derived from a set of Voronoi polygons convering these .\n\n4.2.1 Boundary\n\n\n4.2.2 Segment\n\n\n4.2.3 Point\n\n\n4.2.4 Voronoi\n\n\n4.2.5 Voronoi 2\n\n\n4.2.6 Voronoi simplified network\n\n\n4.2.7 Voronoi line\n\n\n4.2.8 Primal network"
  },
  {
    "objectID": "paper.html#merging-simple-and-detailed-networks",
    "href": "paper.html#merging-simple-and-detailed-networks",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Merging simple and detailed networks",
    "text": "4.3 Merging simple and detailed networks\nAfter you have a simplified version of the network, from any source, the next step is merging the attributes."
  },
  {
    "objectID": "paper.html#footnotes",
    "href": "paper.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "This website hosts the networkmerge paper, results of which are publicly available at https://npt.scot. It was produced with Quarto, which was also used to support the academic paper shown below. See https://quarto.org/docs/websites for further information.\nThe paper is re-built automatically when the source code is updated.\nSee github.com/nptscot/networkmerge for the source code underlying this website."
  },
  {
    "objectID": "index.html#simplifying-the-geometry",
    "href": "index.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 3, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 3.\n\n\n\n\ninput = sf::read_sf('data/minimal-input.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\")\nsimplification_levels = c(1, 0.5, 0.1, 0.001)\n# ordered factor of simplification levels:\nsimplification_df = data.frame(\n  id = as.character(1:length(simplification_levels)),\n  simp_factor = simplification_levels,\n  keep = paste0(\"Keep: \", round(as.numeric(simplification_levels) * 100, 2), \"%\")\n  )\nsimplification_df$keep = ordered(simplification_df$keep, levels = simplification_df$keep)\n\nsmplfy = function(x_list, keep) {\n  x_list = lapply(\n    keep,\n    function(x) {\n      res = rmapshaper::ms_simplify(x_list, keep_shapes = TRUE, keep = x)\n      res$id = x\n      res\n    }\n    )\n  do.call(rbind, x_list)\n}\n# input_simplified = smplfy(input_projected, simplification_levels)\n# sf::write_sf(input_simplified, \"data/input_simplified1.geojson\")\ninput_simplified = sf::read_sf('data/input_simplified1.geojson')\ninput_simplified = left_join(\n  input_simplified,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\ntm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE) \n\n\n\n\n\n\n\ninput = sf::read_sf('data/rnet_princes_street_minimal.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\")\n# input_simplified = smplfy(input_projected, simplification_levels)\n# sf::write_sf(input_simplified, \"data/input_simplified2.geojson\", delete_dsn = TRUE)\ninput_simplified2 = sf::read_sf('data/input_simplified2.geojson')\ninput_simplified = left_join(\n  input_simplified2,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\ntm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE) \n\n\n\n\n\nFigure 3: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\nThe graphic below shows a 2 panel plot showing simplification with the consolidate_intersections function from the osmnx Python package.\n\n\n\n\nimport osmnx as ox\n# Get all streets within 50 m of Princes Street, Edinburgh:\n# Get point that is on Princes Street:\n# ox.geocode_to_gdf(\"Princes Street Edinburgh\")\nG = ox.graph_from_place(\"Royal Scots Greys Memorial\", network_type=\"walk\", buffer_dist=200)\nox.plot_graph(G);\n\n\n\n# Plot the graph in an interactive map:\n# ox.plot_graph_folium(G)\n# project to 27700\n\n\nimport osmnx as ox\nG_projected = ox.project_graph(G, 'EPSG:27700')\n# simplify:\nG_simplified = ox.consolidate_intersections(G_projected, tolerance=10, rebuild_graph=True)\n# plot G_simplified as GeoPandas in Quarto:\nox.plot_graph(G_simplified);\n\n\n\n\n\nFigure 4: Illustration of consolidation of intersections, with the consolidate_intersections function from the osmnx Python package.\n\n\nA more aggressive approach is to simplify and alter network topology in a single step, “through the removal of duplicate or parallel edges, and combining simply-connected nodes” (Deakin 2023). Two approaches to this are outlined below.\n\n\n4.1.2 Network Simplification\nThere are two simplification approaches based presented either using image skeletonization or Voronoi diagram to finding a centre line.\n\n\n4.1.3 Create a projected combined buffered geometry:\nBoth approaches a buffer, in this case 8.0m, is applied to the base network lines.\n\nfrom functools import partial\n\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely import get_coordinates, line_merge, set_precision, unary_union\nplt.rcParams[\"figure.figsize\"] = (12, 12)\n\ndef get_geometry_buffer(this_gf, radius=8.0):\n    \"\"\"get_geometry_buffer: return radius buffered GeoDataFrame\n\n    args:\n      this_gf: GeoDataFrame to\n      radius: (default value = 8.0)\n\n    returns:\n      buffered GeoSeries geometry\n\n    \"\"\"\n    r = gp.GeoSeries(this_gf, crs=CRS).buffer(radius, join_style=\"round\", cap_style=\"round\")\n    union = unary_union(r)\n    try:\n        r = gp.GeoSeries(union.geoms, crs=CRS)\n    except AttributeError:\n        r = gp.GeoSeries(union, crs=CRS)\n    return r\n\nCRS = \"EPSG:27700\"\nbuffer_size = 8.0\n\nset_precision_pointone = partial(set_precision, grid_size=0.1)\nbase_nx = gp.read_file(\"data/rnet_princes_street.geojson\").to_crs(CRS)\nbase_nx[\"geometry\"] = base_nx[\"geometry\"].map(set_precision_pointone)\nnx_geometry = get_geometry_buffer(base_nx[\"geometry\"], radius=buffer_size)\n\nThe buffered street network to be simplified is ::: {.cell layout-ncol=“2”}\nbase_nx.plot(edgecolor=\"blue\", color=\"blue\").grid()\nplt.show()\n\n\n\n\nbase network\n\n\n\nnx_geometry.plot(edgecolor=\"black\", color=\"blue\").grid()\nplt.show()\n\n\n\n\nbuffer network\n\n\n\nEdinburgh Princes Street buffer network :::\n\n\n4.1.4 Skeletonization\nBuffered lines are combined to form a raster image and thinned to produce to a skeletal remnant that preserves the extent and connectivity centred on a line centred on the combined buffered region, using the Edinburgh GeoJSON network as above.\n\n4.1.4.1 Create the affine transformation between the points in the buffer and raster image\nA scaled affine transformations between the projected coordinate geometry and scaled raster image is calculated.\n\nimport numpy as np\nimport pandas as pd\nimport rasterio as rio\nimport rasterio.features as rif\n\ndef get_pxsize(bound, scale=1.0):\n    \"\"\"get_pxsize: calculates scaled image size in px\n\n      bound: boundary corner points\n      scale: scaling factor (default = 1.0)\n\n    returns:\n      size in px\n\n    \"\"\"\n    r = np.diff(bound.reshape(-1, 2), axis=0)\n    r = np.ceil(r.reshape(-1))\n    return (r[[1, 0]] * scale).astype(int)\n\n\ndef get_affine_transform(this_gf, scale=1.0):\n    \"\"\"get_affine_transform: return affine transformations matrices, and scaled image size\n    from GeoPandas boundary size\n\n      this_gf: GeoPanda\n      scale:  (default = 1.0)\n\n    returns:\n      rasterio and shapely affine tranformation matrices, and image size in px\n\n    \"\"\"\n    TRANSFORM_ONE = np.asarray([0.0, 1.0, -1.0, 0.0, 1.0, 1.0])\n    bound = this_gf.total_bounds\n    s = TRANSFORM_ONE / scale\n    s[[4, 5]] = bound[[0, 3]]\n    r = s[[1, 0, 4, 3, 2, 5]]\n    r = rio.Affine(*r)\n    return r, s, get_pxsize(bound, scale)\n\nr_matrix, s_matrix, out_shape = get_affine_transform(nx_geometry, scale=2.0)\n\n\n\n\n4.1.5 Affine transforms\n\n4.1.5.1 Rasterio transform\n\nfrom IPython.display import display, Markdown\ndef display_matrix(matrix, header):\n    r = matrix.to_markdown(index=False, headers=header)\n    display(r)\n\nor_matrix = pd.DataFrame(np.asarray(r_matrix).reshape(-1, 3))\nos_matrix = pd.DataFrame(np.asarray(s_matrix).reshape(3, -1).T)\ndisplay_matrix(or_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0.5 |  0   | 324166 |\n| 0   | -0.5 | 674527 |\n| 0   |  0   |      1 |\n\n\n\n\n4.1.5.2 Shapely transform\n\ndisplay_matrix(os_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0   | -0.5 | 324166 |\n| 0.5 |  0   | 674527 |\n\n\nIn this example a scale factor of 2.0 is used.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to the projected coordinate geometry to create a scaled raster image. The raster image is then cleaned to remove small holes in the image, typically where buffer lines run parallel or intersect at shallow angles.\n\nimport warnings\n\nfrom skimage.morphology import remove_small_holes, skeletonize\nfrom shapely.affinity import affine_transform\nfrom shapely.geometry import Point\nimport rasterio.plot as rip\n\ngeometry_im = rif.rasterize(nx_geometry.values, transform=r_matrix, out_shape=out_shape)\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    geometry_im = remove_small_holes(geometry_im, 4).astype(np.uint8)\n\nrip.show(geometry_im, cmap=\"Blues\", title=\"buffer geometry\")\n\n\n\n\nThe image is then thinned and the resulting giving skeleton raster image.\n\nskeleton_im = skeletonize(geometry_im).astype(np.uint8)\npoint_im = np.stack(np.where(skeleton_im &gt;= 1))\nrip.show(skeleton_im, cmap=\"Blues\", title=\"skeleton geometry\")\n\n\n\nnx_point = gp.GeoSeries(map(Point, point_im.T), crs=CRS)\n\nThe point geometry can then be transformed back to a point geometry.\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\ntransform_point = nx_point.map(shapely_transform).map(set_precision_pointone)\ntransform_point.plot(edgecolor=\"black\", color=\"blue\").grid()\nplt.show()\n\n\n\n\nThe issue with this is that rather than points that lie on the simplified network, we need a simplified set of lines not a set. This requires the line geometry to be inferred from associated points.\n\n\n4.1.7 Conversion from point to line geometry\nCreating a simplified line geometry from a skeletonized point set is arguably the most awkward step in creating a simplified network.\nFirst identify all adjacent points, which are points within a 1x1 px square in the raster coordinate system. Then create line segments from lines between all adjacent points, and finally combine and the resultant lines geometries.\n\nfrom shapely import get_coordinates\nfrom shapely.geometry import LineString, MultiLineString\n\ndef get_raster_line_with_knots(point):\n    \"\"\"get_raster_line_with_knots: return LineString GeoSeries from 1px line points with knots\n\n    args:\n      point: 1px point GeoSeries array with knots\n\n    returns:\n      1px line LineString GeoSeries with knots removed\n\n    \"\"\"\n    square = point.buffer(1, cap_style=\"square\", mitre_limit=1)\n    ix = point.sindex.query(square, predicate=\"covers\").T\n    ix = np.sort(ix)\n    s = pd.DataFrame(ix).drop_duplicates().reset_index(drop=True)\n    s = s.loc[np.where(s[0] != s[1])]\n    s = np.stack([point[s[0].values], point[s[1].values]]).T\n    r = gp.GeoSeries(map(LineString, s), crs=CRS)\n    edge, node = get_source_target(combine_line(r).to_frame(\"geometry\"))\n    return combine_line(edge[\"geometry\"])\n\ndef get_end(geometry):\n    \"\"\"get_end: return numpy array of geometry LineString end-points\n\n    args:\n      geometry: geometry LineString\n\n    returns:\n      end-point numpy arrays\n\n    \"\"\"\n    r = get_coordinates(geometry)\n    return np.vstack((r[0, :], r[-1, :]))\n\ndef get_source_target(line):\n    \"\"\"get_source_target: return edge and node GeoDataFrames from LineString with unique\n    node Point and edge source and target\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node: GeoDataFrames\n\n    \"\"\"\n    edge = line.copy()\n    r = edge[\"geometry\"].map(get_end)\n    r = np.stack(r)\n    node = gp.GeoSeries(map(Point, r.reshape(-1, 2)), crs=CRS).to_frame(\"geometry\")\n    count = node.groupby(\"geometry\").size().rename(\"count\")\n    node = node.drop_duplicates(\"geometry\").set_index(\"geometry\", drop=False)\n    node = node.join(count).reset_index(drop=True).reset_index(names=\"node\")\n    ix = node.set_index(\"geometry\")[\"node\"]\n    edge = edge.reset_index(names=\"edge\")\n    edge[\"source\"] = ix.loc[map(Point, r[:, 0])].values\n    edge[\"target\"] = ix.loc[map(Point, r[:, 1])].values\n    return edge, node\n\ndef combine_line(line):\n    \"\"\"combine_line: return LineString GeoSeries combining lines with intersecting endpoints\n\n    args:\n      line: mixed LineString GeoSeries\n\n    returns:\n      join LineString GeoSeries\n\n    \"\"\"\n    r = MultiLineString(line.values)\n    return gp.GeoSeries(line_merge(r).geoms, crs=CRS)\n\nnx_line = get_raster_line_with_knots(nx_point)\n\nTo see the simplified network requires the reverse affine transformation to be applied,\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.8 Knots\nWhere lines intersect multiple short segment may occur which look like knots.\nTo remove these these short segments are clustered, a cluster centre-point calculated, end-points of longer-lines connected to the segment cluser are then moved to cluster centre-point, removing the knot. As before, prior to plotting the simplified network the reverse affine transformation is applied,\n\nimport networkx as nx\nfrom shapely.geometry import MultiPoint\n\ndef get_raster_line_without_knot(this_line):\n    \"\"\"get_raster_line_without_knot: remove knots from LineString GeoSeries\n\n    args:\n      this_line: LineString GeoSeries array with knots\n\n    returns:\n      LineString GeoSeries with knots removed\n\n    \"\"\"\n    edge, node = get_source_target(this_line)\n    ix = edge.length &gt; 2.0\n    connected = get_connected_class(edge.loc[~ix, [\"source\", \"target\"]])\n    node = node.loc[connected.index].join(connected).sort_index()\n    connected_edge = get_centre(node)\n    r = combine_line(pd.concat([connected_edge[\"geometry\"], edge.loc[ix, \"geometry\"]]))\n    return r[r.length &gt; 2.0]\n\n\ndef get_connected_class(edge):\n    \"\"\"get_connected_class: return labeled connected node pandas Series from edge list\n\n    args:\n      edge_list: source, target edge pandas DataFrame\n\n    returns:\n      labeled node pandas Series\n\n    \"\"\"\n    nx_graph = nx.from_pandas_edgelist(edge)\n    connected = nx.connected_components(nx_graph)\n    r = {k: i for i, j in enumerate(connected) for k in j}\n    return pd.Series(r, name=\"class\")\n\ndef get_centre(node):\n    \"\"\"get_centre_edge: return centroid Point from discrete node clusters\n\n    args:\n      node: discrete node cluster GeoDataSeries\n\n    returns:\n      GeoDataCentre node cluster centroid Point\n\n    \"\"\"\n    centre = node[[\"geometry\", \"class\"]].groupby(\"class\").aggregate(tuple)\n    centre = gp.GeoSeries(centre[\"geometry\"].map(MultiPoint), crs=CRS).centroid\n    centre = centre.rename(\"target\")\n    geometry = node[[\"class\", \"geometry\"]].set_index(\"class\").join(centre)\n    geometry = geometry.apply(LineString, axis=1)\n    r = node.rename(columns={\"node\": \"source\"}).copy()\n    r[\"geometry\"] = geometry.values\n    return r\n\n\nnx_line = get_raster_line_without_knot(nx_line.to_frame(\"geometry\"))\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.9 Primal network\nThere are circumstances where it may useful to see a “primal” network, that only consists of lines from start and end points,\n\ndef get_nx(line):\n    \"\"\"get_nx: return primal edge and node network from LineString GeoDataFrame\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node GeoDataFrames\n\n    \"\"\"\n    r = line.map(get_end)\n    edge = gp.GeoSeries(r.map(LineString), crs=CRS)\n    r = np.vstack(r.to_numpy())\n    r = gp.GeoSeries(map(Point, r)).to_frame(\"geometry\")\n    r = r.groupby(r.columns.to_list(), as_index=False).size()\n    return edge\n\n\nnx_edge = get_nx(nx_line)\nnx_output = nx_edge.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#simplification-via-voronoi-polygons",
    "href": "index.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach lines are buffered, the buffer edges segmented into sequences of points and a centre-line derived from a set of Voronoi polygons convering these .\n\n4.2.1 Boundary\n\nfrom shapely import box\nfrom shapely.ops import voronoi_diagram\n\nscale = 5.0\ntolerance=1.0\n\ndef get_geometry_line(this_buffer):\n    \"\"\"get_geometry_line: returns LineString boundary from geometry\n\n    args:\n      this_buffer: geometry to find LineString\n\n    returns:\n       simplified LineString boundary\n    \"\"\"\n    r = this_buffer.boundary.explode(index_parts=False).reset_index(drop=True)\n    return gp.GeoSeries(r.simplify(tolerance=0.5), crs=CRS)\n\nnx_boundary = get_geometry_line(nx_geometry)\nnx_boundary.plot()\nplt.show()\n\n\n\n\n\n\n4.2.2 Segment\n\ndef get_segment_nx(line, scale):\n    \"\"\"get_segment_nx: segment line into sections, no more than scale long\n\n    args:\n      line:  line to segment\n      scale: length to segment line\n\n    returns:\n      segmented LineStrings\n\n    \"\"\"\n    set_segment = partial(get_segment, distance=scale)\n    r = line.map(set_segment).explode().rename(\"geometry\")\n    return gp.GeoDataFrame(r, crs=CRS)\n\ndef get_linestring(line):\n    \"\"\"get_linestring: return LineString GeoSeries from line coordinates\n\n    args:\n      line:\n\n    returns:\n       LineString GeoSeries\n    \"\"\"\n    r = get_coordinates(line)\n    r = np.stack([gp.points_from_xy(*r[:-1].T), gp.points_from_xy(*r[1:].T)])\n    return gp.GeoSeries(pd.DataFrame(r.T).apply(LineString, axis=1), crs=CRS).values\n\ndef get_segment(line, distance=50.0):\n    \"\"\"get_segment: segment LineString GeoSeries into distance length segments\n\n    args:\n      line: GeoSeries LineString\n      length: segmentation distance (default value = 50.0)\n\n    returns:\n      GeoSeries of LineStrings of up to length distance\n\n    \"\"\"\n    return get_linestring(line.segmentize(distance))\n\nnx_segment = get_segment_nx(nx_boundary, scale).reset_index(drop=True)\nnx_segment.plot()\nplt.show()\n\n\n\n\n\n\n4.2.3 Point\n\nnx_point = nx_segment.loc[:, \"geometry\"].map(get_coordinates).explode()\nnx_point = MultiPoint(nx_point[::2].map(Point).values)\nnx_output = gp.GeoSeries(nx_point, crs=CRS)\nnx_output.plot(edgecolor=\"blue\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n4.2.4 Voronoi\n\nnx_envelope = box(*nx_point.bounds)\nnx_voronoi = voronoi_diagram(nx_point, envelope=nx_envelope, tolerance=tolerance, edges=True)\nnx_voronoi = gp.GeoSeries(map(set_precision_pointone, nx_voronoi.geoms), crs=CRS)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.5 Voronoi 2\n\nnx_voronoi = nx_voronoi.explode(index_parts=False).clip(nx_envelope)\nix = ~nx_voronoi.is_empty & (nx_voronoi.type == \"LineString\")\nnx_voronoi = nx_voronoi[ix].reset_index(drop=True)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.6 Voronoi simplified network\n\ndef get_voronoi_line(voronoi, boundary, geometry, buffer_size):\n    \"\"\"get_voronoi_line: returns cleaned simplified line by filtering Voronoi lines by distance,\n    contained within network buffer Polygons, and combining overlapping end-points\n\n    args:\n      voronoi:     Voronoi LineString\n      boundary:    network buffer LineString\n      geometry:    network buffer Polygon\n      buffer_size: network buffer distance [m]\n\n    returns:\n      simplified simplified network line\n\n    \"\"\"\n    offset = buffer_size / 2.0\n    r = filter_distance(voronoi, boundary, offset)\n    r = filter_buffer(r, geometry)\n    edge, node = get_source_target(r.to_frame(\"geometry\"))\n    ix = node[\"count\"] &lt; 4\n    square = node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\n    square = gp.GeoSeries(unary_union(square.values).geoms, crs=CRS)\n    r = edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\n    r = set_geometry(r, square)\n    return combine_line(r)\n\ndef filter_distance(line, boundary, offset):\n    \"\"\"filter_distance: filter line closer than distance offset from boundary\n\n    args:\n      line:     LineStrings to simplify\n      boundary: boundary LineString\n      offset:\n\n    returns:\n      simplified LineStrings\n    \"\"\"\n    edge, _ = get_source_target(line.to_frame(\"geometry\"))\n    (ix, _), distance = boundary.sindex.nearest(edge[\"geometry\"], return_distance=True)\n    _, ix = np.unique(ix, return_index=True)\n    ix = distance[ix] &gt; offset\n    return combine_line(edge.loc[ix, \"geometry\"]).simplify(1.0)\n\ndef filter_buffer(line, geometry):\n    \"\"\"filter_buffer: filter keeping lines within boundary Polygon\n\n    args:\n      line:     LineStrings to simplify\n      geometry: boundary Polygon\n\n    returns:\n      filtered LineStrings\n    \"\"\"\n    (_, ix) = line.sindex.query(geometry, predicate=\"contains_properly\")\n    return combine_line(line.loc[ix]).simplify(1.0)\n\ndef set_geometry(line, square):\n    \"\"\"set_geometry: return LineString simplified by combining overlapping end-points\n\n    args:\n      line:     LineStrings to simplify\n      square:   overlapping squares\n\n    returns:\n      simplified LineStrings\n\n    \"\"\"\n    r = line.reset_index(drop=True)\n    centroid = square.centroid.map(set_precision_pointone).set_crs(CRS)\n    edge, node = get_source_target(r)\n    ix = node[\"geometry\"].sindex.query(square, predicate=\"contains_properly\")\n    node.loc[ix[1], \"geometry\"] = centroid[ix[0]].values\n    source = node.loc[edge[\"source\"], \"geometry\"].values\n    target = node.loc[edge[\"target\"], \"geometry\"].values\n    r = np.stack([source, target]).T\n    return gp.GeoSeries(map(LineString, r), crs=CRS)\n\n#nx_line = get_voronoi_line(nx_voronoi, nx_boundary, nx_geometry, buffer_size)\n\noffset = buffer_size / 2.0\nnx_line = filter_distance(nx_voronoi, nx_boundary, offset)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.7 Voronoi line\n\nnx_line = filter_buffer(nx_line, nx_geometry)\nnx_edge, nx_node = get_source_target(nx_line.to_frame(\"geometry\"))\nix = nx_node[\"count\"] &lt; 4\nnx_square = nx_node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\nnx_square = gp.GeoSeries(unary_union(nx_square.values).geoms, crs=CRS)\nnx_line = nx_edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\nnx_line = set_geometry(nx_line, nx_square)\nnx_line = combine_line(nx_line)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.8 Primal network\n\nnx_edge = get_nx(nx_line)\nnx_edge.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#merging-simple-and-detailed-networks",
    "href": "index.html#merging-simple-and-detailed-networks",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Merging simple and detailed networks",
    "text": "4.3 Merging simple and detailed networks\nAfter you have a simplified version of the network, from any source, the next step is merging the attributes."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  }
]