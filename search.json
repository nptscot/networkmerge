[
  {
    "objectID": "slides.html#references",
    "href": "slides.html#references",
    "title": "Reproducible methods for network simplification",
    "section": "",
    "text": "References\n\n\n\n\nMorgan, Malcolm, and Robin Lovelace. 2020. “Travel Flow Aggregation: Nationally Scalable Methods for Interactive and Online Visualisation of Transport Behaviour at the Road Network Level.” Environment & Planning B: Planning & Design, July. https://doi.org/10.1177/2399808320942779."
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Networkmerge methods",
    "section": "",
    "text": "Both input datasets were sourced from the Propensity to Cycle Tool (PCT) which in turn is based on OpenStreetMap (OSM) (see the ‘parenex cookbook’, a technical appendix that accomanies this paper, for an example of the method applied to a rail network dataset).\nThe Ottley Road example, which comprises 21 segments, represents an important single carriageway road in Leeds. The main road is represented by a single centreline and with a simplified representation of a roundabout in the northwest (top left) and side roads. The Armley Road example, which comprises 27 segments, by contrast, represents a more complex corridor that is represented by multiple parallel ‘braided’ linestrings on OpenStreetMap. In addition to linestrings representing the road, the corridor contains parallel linestrings representing cycleways.\nThere are two main challenges that need to be overcome to simplify transport networks, in a way that preserves their value:\nSections Section 1 to Section 3 describe methods for simplifying the geometry of the network. The key contributions of the paper are the novel methods of image skeletonization, presented in Section 2, and simplification with Voronoi diagrams to identify central lines, covered in Section 3. To make use of simplified networks in transport planning, it is also necessary to assign attributes to the simplified network. This is covered in Section 5."
  },
  {
    "objectID": "methods.html#sec-topology-preserving-simplification",
    "href": "methods.html#sec-topology-preserving-simplification",
    "title": "Networkmerge methods",
    "section": "1 Topology-preserving simplification",
    "text": "1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving (or at least attempting to preserve) the topology of the network, i.e. not merging parallel lines. As shown in top panel of Figure 2, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process."
  },
  {
    "objectID": "methods.html#sec-simplification-via-skeletonization",
    "href": "methods.html#sec-simplification-via-skeletonization",
    "title": "Networkmerge methods",
    "section": "2 Simplification via skeletonization",
    "text": "2 Simplification via skeletonization\nThe skeletonization approach generates a simplified network by buffering the network, applying an image skeletonization algorithm, and extracting lines segements from a raster of this buffer.\n\nIn both the skeletonization and Voronoi approaches, the network simplification process starts by applying a buffer to linear geometry in a projected, rather than coordinate system.  We use a buffer size of 8 meters in this paper, which roughly corresponds to the width of a typical road, with the result illustrated in Figure 3.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Buffered versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n2.1 Network skeletonization\nIn skeletonization, overlapping lines are identified, buffered, transformed into a raster image, the image processed through a thinning algorithm, and a skeletal representation of the original network produced. This skeletal structure preserves the overall extent and connectivity of the network, with a central line that follows the centre-line of the combined buffered area.\nIn detail, skeletonization is only applied where more than line-segment buffer overlaps. To identify overlapping line-segments, the buffer is split at the end of each line-segment, see top Otley Road (left) and Armley Road (right) Figure 4. The overlapping line-segments are then buffered while retaining the remaining disjoint lines, shown in bottom Figure 4.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Segmented line-buffer geometries (top) and geometries to be skeletonized (bottom) for the Otley Road (left) and Armley Road (right) networks.\n\n\n\nAs detail is lost in transforming of the geometry to an image buffer or raster, more detail can be retained by using an affine transformation to increase the number of points in the buffer prior to skeletonization and reducing scale when creating the simplified linear geometric representation. \n\n\n\nThe raster image also requires pre-processing to eliminate small holes that appear where buffered lines run parallel or intersect at shallow angles. The result of the scale and cleaned raster is illustrated in Figure 5.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Rasterized versions of the Otley Road (left) and Armley Road (right) networks, with post processing to remove small holes.\n\n\n\nThe skeltonisation algorithm is then appled to the raster image yielding a skeletal raster image, as shown in Figure 6. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Skeletonized versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n\n2.2 Recreating a linear geometry\nThe rasterized skeletal image is then converted back into a linear vector geometry, completing the vector-to-raster-to-vector geometry transformation:\n\n\n\nAdjacent points are identifed, typically within a 1x1 pixel square, based on proximity within the raster image coordinate system. Line segments are then created by connecting these adjacent points. These points are combined, giving a continuous line geometry representing the simplified network. Finally, a reverse scaling affine transformation is applied to return to the original coordinate system. \nNoting that creating a line geometry from the set of points in the raster buffer is arguable the most complex step.\nThe resulting simplified network is illustrated in Figure 7.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Simplified versions of the Otley Road (left) and Armley Road (right) networks, transformed back into line geometry."
  },
  {
    "objectID": "methods.html#sec-simplification-via-voronoi-polygons",
    "href": "methods.html#sec-simplification-via-voronoi-polygons",
    "title": "Networkmerge methods",
    "section": "3 Simplification via Voronoi polygons",
    "text": "3 Simplification via Voronoi polygons\nIn this approach, the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a centre-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n3.1 Boundary Segmentation\nIn Figure 8, the boundary of the buffered input geometry (otley_geometry) is calculated and then simplified. This process yields a simplified GeoSeries consisting of LineStrings, all of which are precisely aligned with the specified coordinate reference system (CRS). This step illustrates the transformation from the initial buffer geometries, named ‘otley_buffer’ and ‘Armley_buffer’, to their more refined and simplified versions, ‘otley_boundary’ and ‘Armley_boundary’, respectively. These refined boundaries provide an accurate representation and visualization of the exact limits of the spatial objects involved.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Simplified boundaries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nFigure 9 showcase the conversion of segmented LineString geometries into point geometries. This essential transformation forms the basis for constructing Voronoi diagrams.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Detail segmented boundaries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nFigure 10, the process of converting the segmented LineString geometries into point geometries is illustrated. This transformation is essential for the creation of Voronoi diagrams.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Detail point segement of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n\n\n3.2 Voronoi diagram simplification\nIn Figure 11, the generation and clipping of the corresponding Voronoi diagrams to the bounds of the input geometry is depicted.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Clipped Voronoi diagrams of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\nFigure 12 shows the Voronoi lines that are completely enclosed within the buffer geometry and are situated at a distance of less than half the buffer’s width from the buffer edge. This selective visualization of Voronoi lines effectively demonstrates the method precision in capturing and representing the central alignment of the transport network within its buffered confines.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Voronoi diagram lines with lines that are completely within the buffer geometry and less than half-a-buffer-width from the buffer edge.\n\n\n\n\nThe final center-line network shown in Figure 13 is created through a clean up process that involves the removal of knot-like features from the simplified network. While knots common to both skeletonization and Voronoi simplification, these artefacts are more prevalent on Voronoi simplified networks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Simplified versions of the Otley Road (left) and Armley Road (right) networks."
  },
  {
    "objectID": "methods.html#post-processing",
    "href": "methods.html#post-processing",
    "title": "Networkmerge methods",
    "section": "4 Post-Processing",
    "text": "4 Post-Processing\nBoth skeletonization and Voronoi simplified networks require post-processing to remove unwanted knots. Optionally by removing intermediate lines-sections, a further simplified or primal network that captures the essential connectivity and layout of transport routes can be generated.\n\n4.1 Knots\nKnots in the network are multiple short segments at intersections, resembling tangled knots. To remove these features of networks, which add complexity that is rarely relevant for strategic transport planning, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context, as illustrated in Figure 14.\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 14: Zoomed in versions of road structure with knots (left), and with knots removed (right) shown in Figure 14.\n\n\n\n\n\n4.2 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points. This primal network represents an extreme form of simplification, of great potential value in situations in which the network’s overall structure and compression ratios are priorities.\nThe primal networks for the Otley Road and Armley Road skeletonized networks are illustrated in Figure 15.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Primal skeletonized networks for the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\nFigure 16 illustrates the primal network derived from the Voronoi approach.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Primal Voronoi networks for the Otley Road (left) and Armley Road (right) networks."
  },
  {
    "objectID": "methods.html#sec-joining-route-networks",
    "href": "methods.html#sec-joining-route-networks",
    "title": "Networkmerge methods",
    "section": "5 Joining route networks",
    "text": "5 Joining route networks\nAfter generating a simplified network using the methods described in the previous sections or through an alternative approach, the next crucial step involves transferring attribute values from the detailed network to the simplified one. This process is commonly referred to as ‘conflation’ and ‘integration’. Conflation is essential because while the source file (detailed network) might be rich in attributes like street names, address ranges, and zip codes, it may lack positional accuracy. Conversely, the target file (simplified network) is likely to be positionally precise but deficient in detailed attributes. As noted by (Sutton 1998), network data integration encompasses two key aspects: the geometric integration, involving the link and node feature elements, and the integration of attributes such as highway data. In our context, the purpose of the joining stage is to merge the detailed attributes from the source network onto the geometrically simplified target network. This ‘joining’ step is vital for using simplified networks as the basis for presenting model outputs generated on a complex network in a easy-to-interpret form. \nThe process is analogous to joining two datasets based on a common ‘key’ variable. In this case there is no definitive key, meaning that network joining can be regarded as a ‘fuzzy’ or ‘keyless’ join process (Suri et al., n.d.; Wachowicz and Mrozek 2019): as with the network simplification steps outlined above, the user must select joining parameters to maximise the accuracy of the join. The simplified (typically denoted ‘x’) object can also be referred to as the ‘target’ object, following the terminology used to describe database and ‘spatial similarity’ joins (Ballesteros, Cary, and Rishe 2011). There are at least a couple of implementations of network joining approaches in open source software: the rnet_merge() function in the stplanr R package (Lovelace, Ellison, and Morgan 2019), and the rnetmatch Rust crate which has binding to R and (soon) Python. The details of network joining methods, algorithms and implementations are outside the scope of this paper, see the documentation associated with the projects mentioned above for more information."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "networkmerge",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render paper.qmd\nInstall the dependencies by cloning the repository and running the following:\n# Update rust to unstable latest version:\nrustup update nightly\n\n# Install remotes if not already:\nif (!requireNamespace(\"remotes\")) {\n  install.packages(\"remotes\")\n}\n\nLoading required namespace: remotes\n\ninstall.packages(\n  'rsgeo', \n  repos = c('https://josiahparry.r-universe.dev', 'https://cloud.r-project.org')\n)\n\nInstalling package into '/home/runner/work/_temp/Library'\n(as 'lib' is unspecified)\n\nlibrary(rsgeo)\n# Install if not already:\nif (!requireNamespace(\"networkmerge\")) {\n  # Install github version if no DESCRIPTION file:\n  if (!file.exists(\"DESCRIPTION\")) {\n    remotes::install_github(\"nptscot/networkmerge\")\n  } else {\n    # Install from DESCRIPTION file:\n    remotes::install_local()\n  }\n}\n\nLoading required namespace: networkmerge\n\n\nWarning: replacing previous import 'data.table::first' by 'dplyr::first' when\nloading 'networkmerge'\n\n\nWarning: replacing previous import 'data.table::last' by 'dplyr::last' when\nloading 'networkmerge'\n\n\nWarning: replacing previous import 'data.table::between' by 'dplyr::between'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'curl::handle_reset' by 'httr::handle_reset'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'magrittr::set_names' by 'rlang::set_names'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'data.table:::=' by 'rlang:::=' when loading\n'networkmerge'\n\n\nWarning: replacing previous import 'jsonlite::flatten' by 'rlang::flatten' when\nloading 'networkmerge'\n\n\nWarning: replacing previous import 'jsonlite::unbox' by 'rlang::unbox' when\nloading 'networkmerge'\n\n\nWarning: replacing previous import 'lwgeom::st_perimeter' by 'sf::st_perimeter'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'lwgeom::st_minimum_bounding_circle' by\n'sf::st_minimum_bounding_circle' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_id_szudzik' by\n'stplanr::od_id_szudzik' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_to_odmatrix' by\n'stplanr::od_to_odmatrix' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::odmatrix_to_od' by\n'stplanr::odmatrix_to_od' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_id_order' by 'stplanr::od_id_order'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_id_character' by\n'stplanr::od_id_character' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_id_max_min' by\n'stplanr::od_id_max_min' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'od::od_oneway' by 'stplanr::od_oneway' when\nloading 'networkmerge'\n\n\nWarning: replacing previous import 'ggplot2::geom_line' by 'rsgeo::geom_line'\nwhen loading 'networkmerge'\n\n\nWarning: replacing previous import 'ggplot2::geom_polygon' by\n'rsgeo::geom_polygon' when loading 'networkmerge'\n\n\nWarning: replacing previous import 'ggplot2::geom_point' by 'rsgeo::geom_point'\nwhen loading 'networkmerge'\n\nrequirements_txt = readLines(\"requirements.txt\")\n# Check if Python is installed:\nif (!requireNamespace(\"reticulate\")) {\n  install.packages(\"reticulate\")\n}\n# See reticulate documentation to use a specific Python version:\n# ?reticulate::install_python()\nreticulate::install_python(\"3.12.4\")\n\nInstalling pyenv ...\nDone! pyenv has been installed to '/home/runner/.local/share/r-reticulate/pyenv/bin/pyenv'.\n\n\n+ /home/runner/.local/share/r-reticulate/pyenv/bin/pyenv update\n\n\n+ /home/runner/.local/share/r-reticulate/pyenv/bin/pyenv install --skip-existing 3.12.4\n\n\n[1] \"/home/runner/.pyenv/versions/3.12.4/bin/python3.12\"\n\n# Install Python dependencies with reticulate:\nreticulate::py_install(requirements_txt, pip = TRUE)\n\nUsing Python: /home/runner/.pyenv/versions/3.12.4/bin/python3.12\nCreating virtual environment '~/.virtualenvs/r-reticulate' ... \n\n\n+ /home/runner/.pyenv/versions/3.12.4/bin/python3.12 -m venv /home/runner/.virtualenvs/r-reticulate\n\n\nDone!\nInstalling packages: pip, wheel, setuptools\n\n\n+ /home/runner/.virtualenvs/r-reticulate/bin/python -m pip install --upgrade pip wheel setuptools\n\n\nVirtual environment '~/.virtualenvs/r-reticulate' successfully created.\nUsing virtual environment '~/.virtualenvs/r-reticulate' ...\n\n\n+ /home/runner/.virtualenvs/r-reticulate/bin/python -m pip install --upgrade --no-user 'parenx &gt;= 0.5.5' 'folium &gt;= 0.14.0' 'geopandas &gt;= 0.13.2' 'mapclassify &gt;= 2.6.0' 'matplotlib &gt;= 3.7.2' 'networkx &gt;= 3.1.0' 'osmnx &gt;= 1.6.0' 'pandas &gt;= 2.0.3' 'rasterio &gt;= 1.3.9' 'scikit-image &gt;= 0.22.0' 'scipy &gt;= 1.11.1' 'shapely &gt;= 2.0.1' 'jupyter &gt;= 1.0.0' 'tabulate &gt;= 0.9.0' 'nbformat &gt;= 5.1.3'\n\n\nThis website hosts the networkmerge paper which presents methods for simplifying route networks for transport planning. The methods were developed for the Network Planning Tool for Scotland which is publicly available at https://npt.scot.\n\nIt was produced with Quarto, which was also used to support the academic paper shown below. See https://quarto.org/docs/websites for further information.\nThe paper is re-built automatically when the source code is updated:\n\n\n\nQuarto Publish\n\n\nSee github.com/nptscot/networkmerge for the source code underlying this website."
  },
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "Route network datasets are central to transport models as key inputs and outputs. The complexity of route network inputs from sources such as OpenStreetMap (OpenStreetMap contributors 2024) has increased over time, enabling more precise modelling of sustainable modes such as walking and cycling. However, this complexity can affect the visualisation of model results. A common issue is the presence of multiple parallel ways on the same corridor, which can lead to visual artefacts and misinterpretation of model outputs. To address these challenges, we present and compare two methods for simplifying route network datasets: 1) image skeletonization and 2) Voronoi diagram-centreline identification. These methods have real-world applications, as illustrated in the “Simplified network” layer in the Transport for Scotland funded Network Planning Tool, which is publicly available at www.npt.scot. Based on open access data and the open source parenx Python package, available on the Python Package Index, these methods are not only reproducible but also adaptable, enabling their use in new contexts."
  },
  {
    "objectID": "paper.html#sec-simplification-via-skeletonization",
    "href": "paper.html#sec-simplification-via-skeletonization",
    "title": "Route network simplification for transport planning",
    "section": "3.1 Simplification via skeletonization",
    "text": "3.1 Simplification via skeletonization\nThe skeletonization approach generates a simplified network by buffering the network, applying an image skeletonization algorithm, and extracting lines segements from a raster of this buffer.\n\nIn both the skeletonization and Voronoi approaches, the network simplification process starts by applying a buffer to linear geometry in a projected, rather than coordinate system.  We use a buffer size of 8 metres in this paper. This value is informed by typical widths of a UK two-lane highway with an example for a typical 2-way road being specified in the Design Manual for Roads and Bridges (DMRB) as “min 4.8 m, max 8.8 m” and the minimum GB rail centre-line track separation of 3.26m, and two sections of 1.435m standard gauge.\n\nIn skeletonization, overlapping lines are identified, buffered, transformed into a raster image, the image processed through a thinning algorithm, and a skeletal representation of the original network produced (see Methods appendix for details). This skeletal structure preserves the overall extent and connectivity of the network, with a central line that follows the centre-line of the combined buffered area.\nIn detail, skeletonization is only applied where more than line-segment buffer overlaps. To identify overlapping line-segments, the buffer is split at the end of each line-segment. The overlapping line-segments are then buffered while retaining the remaining disjoint lines.\n\n\n\n\n\nAs detail is lost in transforming of the geometry to an image buffer or raster, more detail can be retained by using an affine transformation to increase the number of points in the buffer prior to skeletonization and reducing scale when creating the simplified linear geometric representation. This scale operation is a uniform affine scale transformation applied to increase the detail contained in the raster image. An increase in scale reduces undulation but at the cost of longer processing time and increased memory, which varies as the square of scale value. This transformation is scaled to ensure that the projected coordinate geometry of the network aligns accurately with the corresponding dimensions of the scaled raster image.\nThe raster image also requires pre-processing to eliminate small holes that appear where buffered lines run parallel or intersect at shallow angles. The skeletonization algorithm is then applied to the raster image yielding a skeletal raster image and converted back into a linear vector geometry, completing the vector-to-raster-to-vector geometry transformation (see Methods appendix for details).\n\n\n\n\n\n\n\n\n\nAdjacent points are identifed, typically within a 1x1 pixel square, based on proximity within the raster image coordinate system. Line segments are then created by connecting these adjacent points. These points are combined, giving a continuous line geometry representing the simplified network. Finally, a reverse scaling affine transformation is applied to return to the original coordinate system. \nIt should be noted that creating a line geometry from the set of points in the raster buffer is arguably the most complex step in the skeletonization process."
  },
  {
    "objectID": "paper.html#sec-simplification-via-voronoi-polygons",
    "href": "paper.html#sec-simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "3.2 Simplification via Voronoi polygons",
    "text": "3.2 Simplification via Voronoi polygons\nVoronoi simplification takes the buffered network segments and converts them into a set of points. The edges of these buffers are then segmented into sequences of points. From these sequences, a centre-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVoronoi lines that are completely enclosed within the buffer geometry and are situated at a distance of less than half the buffer’s width from the buffer edge are selected. This selective visualization of Voronoi lines effectively demonstrates the method precision in capturing and representing the central alignment of the transport network within its buffered confines. The final center-line network is created through a clean up process that involves the removal of knot-like features from the simplified network. While knots are common to both skeletonization and Voronoi simplification, these artefacts are more prevalent on Voronoi simplified networks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Original and simplified versions of the Otley Road (top) and Armley Road (bottom) networks. From left to right: original network, skeletonized network, Voronoi simplified network."
  },
  {
    "objectID": "paper.html#post-processing",
    "href": "paper.html#post-processing",
    "title": "Route network simplification for transport planning",
    "section": "3.3 Post-Processing",
    "text": "3.3 Post-Processing\nBoth skeletonization and Voronoi simplified networks require post-processing to remove unwanted knots, short segments at intersections, resembling tangled knots. To remove these features, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point, as illustrated in the Methods appendix.\nAn additional optional stage is to simplify the network further by removing vertices that are not essential for the network’s connectivity, resulting in a primal network that captures the essential connectivity and layout of transport routes. The primal network is thus composed of direct lines connecting start and end points, representing a high level of simplification that prioritises the network’s structure and compression.\n\n\n\n\n\n\n\n\n\n\nSee Section 4 in Methods appendix for details."
  },
  {
    "objectID": "paper.html#skeletonization-versus-voronoi",
    "href": "paper.html#skeletonization-versus-voronoi",
    "title": "Route network simplification for transport planning",
    "section": "3.4 Skeletonization versus Voronoi",
    "text": "3.4 Skeletonization versus Voronoi\nBoth the skeletonization and Voronoi approaches are generic methods with the following known issues: they do not preserve links between attributes and the simplified network, nor do they identify subsets of edges that require simplification. Additionally, the resulting lines can be wobbly. The simplification process is memory- and CPU-intensive, and its speed depends on network density and overlap. On commodity hardware, simplifying a core urban road network of 1 km extent takes about 5 seconds, while a 3 km urban core takes between 30 and 60 seconds. Although the Voronoi output is significantly smoother, it is typically 3.6 to 5.1 times slower than skeletonization.\nBased on available computing resources, the Voronoi algorithm is used for smaller networks (e.g., those covering approximately 1 km²), while the skeletonization algorithm is preferred for larger areas (such as 100 km²). Notably, skeletonization of the entire British rail center-line network took about 5 hours."
  },
  {
    "objectID": "paper.html#sec-joining-route-networks",
    "href": "paper.html#sec-joining-route-networks",
    "title": "Route network simplification for transport planning",
    "section": "3.5 Joining route networks",
    "text": "3.5 Joining route networks\nAfter generating a simplified network using the methods, it is often useful to translate attributes from the original network to the simplified network.   In the context of network planning tools, the purpose of the joining stage is to join traffic estimates from the source network onto the geometrically simplified target network (Sutton 1998).  \n\nIn this case there is no definitive key, meaning that network joining can be regarded as a ‘fuzzy’ or ‘keyless’ join process (Suri et al., n.d.; Wachowicz and Mrozek 2019): as with the network simplification steps outlined above, the user must select joining parameters to maximise the accuracy of the join. There are at least a couple of implementations of network joining methods in open source software: the rnet_merge() function in the stplanr R package (Lovelace, Ellison, and Morgan 2019), and the rnetmatch Rust crate for which has bindings to R and Python are planned. The details of network joining methods, algorithms and implementations are outside the scope of this paper, see the documentation associated with the projects mentioned above for more information."
  },
  {
    "objectID": "cookbook.html",
    "href": "cookbook.html",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render cookbook.qmd"
  },
  {
    "objectID": "cookbook.html#create-a-working-directory",
    "href": "cookbook.html#create-a-working-directory",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.1 Create a working directory",
    "text": "2.1 Create a working directory\nOpen a shell command line prompt and type:\nmkdir elegant-tern\ncd elegant-tern"
  },
  {
    "objectID": "cookbook.html#create-and-activate-python3-virtual-environment",
    "href": "cookbook.html#create-and-activate-python3-virtual-environment",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.2 Create and activate python3 virtual-environment",
    "text": "2.2 Create and activate python3 virtual-environment\nCreate a python virtual environment under venv in the working directory:\npython3 -m venv venv\nsource venv/bin/activate\nActivation then means that the scripts and modules installed in the virtual environment are added to the shell execution path."
  },
  {
    "objectID": "cookbook.html#upgrade-the-base-pip-and-wheel-modules-optional",
    "href": "cookbook.html#upgrade-the-base-pip-and-wheel-modules-optional",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.3 Upgrade the base pip and wheel modules (optional)",
    "text": "2.3 Upgrade the base pip and wheel modules (optional)\nThis is to make sure you are working with the lastest version of the python3 package management and installation tools:\npip install --upgrade pip\npip install --upgrade wheel\nThis becomes more important if you are maintaining a pypi project."
  },
  {
    "objectID": "cookbook.html#install-the-parenx-project",
    "href": "cookbook.html#install-the-parenx-project",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.4 Install the parenx project:",
    "text": "2.4 Install the parenx project:\nThis installs the latest release of the parenx scripts from pypi and prints the module version to stdout:\npip install parenx\npython3 -c \"import parenx; from importlib.metadata import version; print(version('parenx'))\"\n0.5.6"
  },
  {
    "objectID": "cookbook.html#simplify-a-linear-network",
    "href": "cookbook.html#simplify-a-linear-network",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.5 Simplify a linear-network",
    "text": "2.5 Simplify a linear-network\nTo simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\nskeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg --buffer 30\nLet’s look at the before and after network:"
  },
  {
    "objectID": "cookbook.html#notes",
    "href": "cookbook.html#notes",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.6 Notes",
    "text": "2.6 Notes\nWhile there are many different takes and system to manage python packages, my experience is that package management in a virtual environment with python3 just works."
  },
  {
    "objectID": "cookbook.html#skeletonize-simplification",
    "href": "cookbook.html#skeletonize-simplification",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "3.1 Skeletonize simplification",
    "text": "3.1 Skeletonize simplification\nAs the script take both a filepath or URL, to simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\nskeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg\nThe base skeletonize.py also takes parameters to split buffered line segments or preserve knots. These parameters:\nskeletonize.py\nstart       0:00:00.000266\nusage: skeletonize.py [-h] [--simplify SIMPLIFY] [--buffer BUFFER] [--scale SCALE] [--knot] [--segment] inpath [outpath]\nskeletonize.py: error: the following arguments are required: inpath"
  },
  {
    "objectID": "cookbook.html#voronoi-simplification",
    "href": "cookbook.html#voronoi-simplification",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "3.2 Voronoi simplification",
    "text": "3.2 Voronoi simplification\nAs the script take a filepath or URL, simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\nskeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg\nThe base voronoi.py also takes a tolerance parameter6 to sets to the Voronoi polygon overlap:\nstart       0:00:00.000154\nusage: voronoi.py [-h] [--simplify SIMPLIFY] [--scale SCALE] [--buffer BUFFER] [--tolerance TOLERANCE] inpath [outpath]\nvoronoi.py: error: the following arguments are required: inpath"
  },
  {
    "objectID": "cookbook.html#find-the-helper-script",
    "href": "cookbook.html#find-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.1 Find the helper script",
    "text": "4.1 Find the helper script\nTo find it:\nfind . -name run.sh\n./venv/lib/python3.12/site-packages/parenx/run.sh"
  },
  {
    "objectID": "cookbook.html#copy-the-helper-script",
    "href": "cookbook.html#copy-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.2 Copy the helper script",
    "text": "4.2 Copy the helper script\nCopy the helper script to the working directory. If you want to check for its existence copy it to the working directory type:\nls run.sh\nls: cannot access 'run.sh': No such file or directory\nfind . -name run.sh -exec cp {} . \\;\nls run.sh\nrun.sh\nOtherwise the following will suffice:\nfind . -name run.sh -exec cp {} . \\;"
  },
  {
    "objectID": "cookbook.html#run-the-helper-script",
    "href": "cookbook.html#run-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.3 Run the helper script",
    "text": "4.3 Run the helper script\nThe default runs the skeletonize and voronoi simplification scripts with a number of parameters, against an OpenStreetMap7 Edinburgh Princes Street road network file (net_princes_street.geojson). It creates a GeoPKG8 with three output layers and, if ogr2ogr is installed, GeoJSON9.\n./run.sh\nsimplify ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nskeletonize ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nstart       0:00:00.000270\nread geojson    0:00:00.093758\n...\nwrite simple    0:00:03.403231\nwrite primal    0:00:03.446779\nstop        0:00:03.498828\nvoronoi ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nstart       0:00:00.000165\nread geojson    0:00:00.079670\n...\nstop        0:00:19.703512"
  },
  {
    "objectID": "cookbook.html#what-does-the-helper-run.sh-do",
    "href": "cookbook.html#what-does-the-helper-run.sh-do",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.4 What does the helper run.sh do?",
    "text": "4.4 What does the helper run.sh do?\nThe helper script creates the enviroment and runs the skeletonize and voronoi simplification scripts with different simplification parameters, and converts the output into a sanitized GeoJSON format if ogr2ogr is installed. The path and output filename can also be specified.\n\n4.4.1 Set up environment\nAs above this checks to see if a venv directory exists, creates and populates it if not, and activates the environment:\n#!/usr/bin/env bash\n\nif [ ! -d venv ]; then\n    python3 -m venv venv\n    source venv/bin/activate\n    pip install --upgrade pip\n    pip install --upgrade wheel\n    pip install parenx\nfi\n\nsource venv/bin/activate\nIt also see if there are any command line parameters set and creates an archive directory, if it is absent:\nLIBPATH=$(find . -name data | fgrep parenx)\nINPATH=${1:-\"${LIBPATH}/rnet_princes_street.geojson\"}\nOUTPUT=${2:-\"output\"}\n\necho simplify ${INPATH}\n\nif [ ! -d archive ]; then\n    mkdir archive\nfi\nThis sets the LIBPATH shell variable to the location of parenx library.\nIt also sets the INPATH and OUTPATH shell variables to command line values, or defaults.\n\n\n4.4.2 Archive previous files\nCreate an archive directory, and archive any existing output files.\nif [ ! -d archive ]; then\n    mkdir archive\nfi\n\nfor k in sk vr\ndo\n    if [ -s ${k}-${OUTPUT}.gpkg ]; then\n        mv ${k}-${OUTPUT}.gpkg archive\n    fi\n    if [ -s ${k}-${OUTPUT}.geojson ]; then\n        mv ${k}-${OUTPUT}.geojson archive\n    fi\ndone\n\n\n4.4.3 Simplify using skeletonization\nThis creates three skeletonization outputs with varying simplify and segment parameters:\necho skeletonize ${INPATH}\nskeletonize.py ${INPATH} sk-${OUTPUT}.gpkg\nskeletonize.py ${INPATH} sk-${OUTPUT}-simple.gpkg --simplify 1.0\nskeletonize.py ${INPATH} sk-${OUTPUT}-segment.gpkg --segment\n\n\n4.4.4 Simplify using Voronoi\nThis creates two Voronoi outputs with varying simplify parameters:\necho voronoi ${INPATH}\nvoronoi.py ${INPATH} vr-${OUTPUT}.gpkg\nvoronoi.py ${INPATH} vr-${OUTPUT}-simple.gpkg --simplify 1.0\n\n\n4.4.5 What does this all look like?\nRemembering less is more:\nless run.sh\n#!/usr/bin/env bash\n\nif [ ! -d venv ]; then\n    python3 -m venv venv\n    source venv/bin/activate\n    pip install --upgrade pip\n    pip install --upgrade wheel\n    pip install parenx\nfi\n\nsource venv/bin/activate\n\nLIBPATH=$(find . -name data | fgrep parenx | head -1)\nINPATH=${1:-\"${LIBPATH}/rnet_princes_street.geojson\"}\nOUTPUT=${2:-\"output\"}\n\necho simplify ${INPATH}\n\nif [ ! -d archive ]; then\n    mkdir archive\nfi\n\nfor k in sk vr\ndo\n    if [ -s ${k}-${OUTPUT}.gpkg ]; then\n        mv ${k}-${OUTPUT}.gpkg archive\n    fi\n    if [ -s ${k}-${OUTPUT}.geojson ]; then\n        mv ${k}-${OUTPUT}.geojson archive\n    fi\ndone\n\necho skeletonize ${INPATH}\nskeletonize.py ${INPATH} sk-${OUTPUT}.gpkg\nskeletonize.py ${INPATH} sk-${OUTPUT}-simple.gpkg --simplify 1.0\nskeletonize.py ${INPATH} sk-${OUTPUT}-segment.gpkg --segment\necho voronoi ${INPATH}\nvoronoi.py ${INPATH} vr-${OUTPUT}.gpkg\nvoronoi.py ${INPATH} vr-${OUTPUT}-simple.gpkg --simplify 1.0\n\nOGR2OGR=$(which ogr2ogr)\nif [ x\"${OGR2OGR}\" != x ]; then\n    for k in sk vr\n    do\n        rm -f ${k}-${OUTPUT}.geojson\n        ogr2ogr -f GeoJSON ${k}-${OUTPUT}.geojson ${k}-${OUTPUT}.gpkg line\n        sed -i 's/00000[0-9]*//g' ${k}-${OUTPUT}.geojson\n    done\n    for k in sk vr\n    do\n        rm -f ${k}-${OUTPUT}-simple.geojson\n        ogr2ogr -f GeoJSON ${k}-${OUTPUT}-simple.geojson ${k}-${OUTPUT}-simple.gpkg line\n        sed -i 's/00000[0-9]*//g' ${k}-${OUTPUT}-simple.geojson\n    done\nfi"
  },
  {
    "objectID": "cookbook.html#footnotes",
    "href": "cookbook.html#footnotes",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe network merge paper here.↩︎\nSee the online project.↩︎\nThe Debian Linux distribution↩︎\nGitHub data used in development.↩︎\nThe simplify parameter sets shapely simplify function tolerance value.↩︎\nThe tolerance parameter set shapely voronoi_diagram function Voronoi snapping tolerance.↩︎\nThe OpenStreetMap map of Edinburgh.↩︎\nThe OSC GeoPKG specification.↩︎\nThe GeoJSON Specification (RFC 7946).↩︎"
  }
]