[
  {
    "objectID": "paper.html#simplifying-the-geometry",
    "href": "paper.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 4, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 4.\n\n\n\n\n\n\n\n\n\nFigure 4: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\n\n\n4.1.2 Network Simplification\nThe paper presents two approaches for network simplification: one involves image skeletonization, while the other utilizes Voronoi diagrams to identify central lines. The detailed steps of the methodology will be presented in the following sections.\n\n\n4.1.3 Create a projected combined buffered geometry:\nIn both approaches, the network simplification process initiates with the generation of buffered geometries, achieved using the get_geometry_buffer function. A buffer size of 8 meters is selected for this purpose. These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.\n\n\n\n\n\nThe buffered versions of the networks are presented below:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Buffered versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n4.1.4 Skeletonization\nThe buffered lines are merged to create a raster image, which is then subjected to a thinning process to yield a skeletal remnant. This remnant retains both the extent and connectivity of the original network, centered around a line that aligns with the combined buffered region. This process is demonstrated using the Sample Street Network.\nEstablish an affine transformation that maps the points within the buffered geometry to corresponding positions in the raster image\nA scaled affine transformation is calculated to align the projected coordinate geometry with the corresponding scaled raster image.\n\n\n4.1.5 Affine transforms\nThe affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0. The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation.\n\n4.1.5.1 Rasterio transform\n\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0.5 |  0   | 426757 |\n| 0   | -0.5 | 437646 |\n| 0   |  0   |      1 |\n\n\n\n\n4.1.5.2 Shapely transform\n\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0   | -0.5 | 426757 |\n| 0.5 |  0   | 437646 |\n\n\nIn these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation. The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image. This transformation adjusts the geometry to match the raster’s scale and orientation. Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles. This step ensures a more coherent and accurate representation in the raster image.\n\n\n\n\n\nThe image undergoes a thinning process, yielding a skeletal raster image as the result. This skeletonized image effectively captures the essential structure and layout of the original network.\n\n\n\n\n\nThe rasterized skeletal image is then converted back into point geometry, completing the transformation process. The rasterized skeletal image is then converted back into point geometry, completing the transformation process.\n\n\n\n\n\nThe challenge with this approach is that instead of generating points situated on the simplified network, it yields a mere set of points. What is required for effective analysis is a simplified set of line geometries, not just isolated points. This necessitates the inference of line geometry from the associated set of points.\n\n\n4.1.7 Transforming point geometry into line geometry\nTransforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.\nThe process of transforming point geometry into line geometry involves several key steps. Initially, the point set, derived from a skeletonized image, is analysed to identify adjacent points. Adjacency is determined based on proximity within the raster coordinate system, usually within a 1x1 pixel square.\nOnce adjacent points are identified, line segments are created by connecting these points. The final and crucial step is the amalgamation of these individual line segments. This combination results in a continuous line geometry that represents the simplified network structure. This conversion from point to line geometry is a pivotal aspect of network simplification.\nTo visualize the simplified network in its original spatial context, it is necessary to apply the reverse affine transformation. This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework.\n\n\n\n\n\n\n\n4.1.8 Knots\nKnots in the network often manifest as multiple short segments at intersections, resembling tangled knots.\nTo address these, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context.\n\n\n\n\n\n\n\n4.1.9 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points."
  },
  {
    "objectID": "paper.html#simplification-via-voronoi-polygons",
    "href": "paper.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach, the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a center-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n4.2.1 Boundary\nThe get_geometry_line funtion is defined to convert a given geometry into a simplified LineString boundary. The function first extracts the boundary of the input geometry and then simplifies it using a set tolerance level. The result is a GeoSeries of the simplified LineString, correctly aligned with a specified coordinate reference system (CRS). This functionality is particularly useful in geographic information systems (GIS) for delineating and visualizing precise boundaries of spatial objects. The code demonstrates its utility by applying the function to a geometry (otley_geometry) and visualizing the resultant simplified boundaries (nx_boundary), highlighting its practical application in spatial analysis and network simplification.\n\n\n\n\n\n\n\n4.2.2 Segment\nThe simplified LineString geometries are then broken down into shorter segments.\n\n\n\n\n\n\n\n4.2.3 Point\nThe simplified LineString geometries are converted into point geometries.\n\n\n\n\n\n\n\n4.2.4 Voronoi\nThe Voronoi diagram is generated from nx_point within the bounds of nx_envelope.\n\n\n\n\n\n\n\n4.2.5 Voronoi 2\n\n\n\n\n\n\n\n4.2.6 Voronoi simplified network\n\n\n\n\n\n\n\n4.2.7 Voronoi line\n\n\n\n\n\n\n\n4.2.8 Primal network"
  },
  {
    "objectID": "paper.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "href": "paper.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Integrating attributes from the detailed network into the simplified network",
    "text": "4.3 Integrating attributes from the detailed network into the simplified network\nIn instances where a simplified version of the network is readily available, such as OS Open Roads, the steps for network simplification can be bypassed. Instead, the focus shifts to integrating attributes from the detailed network into the simplified network. This approach streamlines the process, leveraging pre-existing simplified network data while enriching it with detailed attributes.\nIn this section, we focus on integrating attributes from a detailed route network into a simplified one. We achieve this using the stplanr package in R, a powerful tool designed specifically for transport planning. stplanr emphasizes spatial transport data and is particularly adept at handling non-motorized modes of transportation. More about stplanr can be found on its CRAN page [] (https://cran.r-project.org/web/packages/stplanr/index.html).\nData Preparation:\nThe core functionality of our integration process hinges on two pivotal inputs: rnet_x and rnet_y. Each plays a distinct yet complementary role in the network attribute integration:\n\nrnet_x - Target Route Network: This dataset represents our base framework. It is a streamlined, simplified version of a more intricate network, serving as the foundational geometry. rnet_x is akin to a canvas, prepared to receive additional layers of data. It wroth to note that rnet_x need to contian a identifier columns.\nrnet_y - Source of Additional Attributes: In contrast to rnet_x, rnet_y brings depth and detail. It is the repository of rich, comprehensive attributes that are waiting for transfer to our target network.\n\nStep 1: Coordinate Reference System Alignment\nTransform the spatial data of both rnet_x (the simplified network) and rnet_y (the detailed network) to the same coordinate reference system. For this project, we have selected EPSG:27700.\nStep 2: Defining the Function List\nCreate a function list that dictates how each attribute is to be processed:\n\nExclude: “geometry” from processing.\nMean Function: Applied to attributes like “Gradient” and “Quietness”. TODO expline the funtion of sum and mean\nSum Function: Used for aggregating values in columns such as “all_bicycle”.\n\nStep 3: Using stplanr::rnet_merge for Integration\nEmploy the rnet_merge function from the stplanr package. This function is designed to merge route network data, taking into account the predefined functions and alignment in the coordinate system.\nIn the example code, four arguments need to be carefully defined:\n\ndist (Buffer Distance): This parameter defines the buffer zone around rnet_xp in meters, essential for determining the proximity at which features from both networks are considered for merging. Typically, this value is refined to approximate the width of streets, ensuring a realistic spatial correlation between the network elements.\nsegment_length (Segment Maximum Length): This specifies the upper limit for each segment’s length within the detailed network, here set to 10 meters. Segmenting the network in this manner enhances manageability and contributes to more precise localization of lines within the specified buffer. This granularity is key for achieving higher accuracy in attribute integration.\nfuns (Function List): Comprises a series of functions assigned to process each attribute during the merge. This may involve applying statistical operations, such as calculating the mean or sum of various attributes. The choice of function for each attribute is determined based on the nature of the data and the specific analytical requirements.\nmax_angle_diff (Maximum Angular Difference): This parameter is crucial in regulating the maximum allowable angular deviation between segments and target lines during the merging process. With a set threshold of 20 degrees, it ensures that merging is confined to segments with similar orientations. Such consideration of angular alignment plays a pivotal role in maintaining the network’s geometric integrity. It notably helps in preventing inappropriate attribute transfers, such as avoiding the assignment of values from a road that is perpendicular to another, like in T junction scenarios. By enforcing this restriction on angular differences, the integrity and coherence of the route network’s structure are preserved, ensuring the merged network accurately reflects the true spatial layout and connectivity of the routes.\n\n\n\n\n\n\n\nOnce we obtained the rnet_merged dataset, which is a simplified network but also contains detailed attributes, we then need a series of steps to refine the data:\n\nCleaning: The rnet_merged dataset undergoes an initial cleaning phase where superfluous columns are removed. This step enhances dataset manageability and focuses on relevant data by eliminating columns such as ‘identifier’ and ‘length_x’.\nDimensionality Reduction: Z and M dimensions are removed from the dataset, as they are redundant for our analysis and contribute to unnecessary increases in file size. This reduction simplifies the dataset and optimizes it for storage and processing efficiency.\nNA Handling: A thorough examination is conducted for the presence of NA values across the columns. Any rows where all the targeted columns contain NA values are filtered out.\nSpatial Subsetting: Following the removal of linestrings that contain NA attributes from the rnet_merged dataset, we proceed to create a geometric buffer zone. This zone serves as a spatial criterion for identifying and retaining only those geometries that lie outside of this buffer. A subset of rnet_yp, termed rnet_yp_rest, is then delineated based on this spatial relationship, effectively omitting any geometries that intersect with or fall within the buffered area. This step ensures that only those components of rnet_y which are spatially distinct from rnet_merged are retained for further consideration.\nNetwork Simplification: In the final stage of simplification, the datasets rnet_yp_rest and rnet_merged_all are combined to form the final network, which retains the simplicity of the original simplified structure while concurrently encompassing the detailed attributes, thereby providing a comprehensive yet efficient foundation for further analysis.\n\nBy meticulously following these steps, we ensure that the integration of attributes is not only accurate but also tailored to the specific needs of our analysis."
  },
  {
    "objectID": "paper.html#footnotes",
    "href": "paper.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "This website hosts the networkmerge paper, results of which are publicly available at https://npt.scot. It was produced with Quarto, which was also used to support the academic paper shown below. See https://quarto.org/docs/websites for further information.\nThe paper is re-built automatically when the source code is updated:\nSee github.com/nptscot/networkmerge for the source code underlying this website."
  },
  {
    "objectID": "index.html#simplifying-the-geometry",
    "href": "index.html#simplifying-the-geometry",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Simplifying the geometry",
    "text": "4.1 Simplifying the geometry\n\n\n4.1.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 4, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 4.\n\n\n\n\ninput = sf::read_sf('data/rnet_otley.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\")\nsimplification_levels = c(1, 0.5, 0.1, 0.001)\n# ordered factor of simplification levels:\nsimplification_df = data.frame(\n  id = as.character(1:length(simplification_levels)),\n  simp_factor = simplification_levels,\n  keep = paste0(\"Keep: \", round(as.numeric(simplification_levels) * 100, 2), \"%\")\n  )\nsimplification_df$keep = ordered(simplification_df$keep, levels = simplification_df$keep)\n\nsmplfy = function(x_list, keep) {\n  x_list = lapply(\n    keep,\n    function(x) {\n      res = rmapshaper::ms_simplify(x_list, keep_shapes = TRUE, keep = x)\n      res$id = x\n      res\n    }\n    )\n  do.call(rbind, x_list)\n}\nif (!file.exists(\"data/input_simplified_otley.geojson\")) {\n  input_simplified = smplfy(input_projected, simplification_levels)\n  sf::write_sf(input_simplified, \"data/input_simplified_otley.geojson\", delete_dsn = TRUE)\n} else {\n  input_simplified = sf::read_sf('data/input_simplified_otley.geojson')\n}\n\ninput_simplified = left_join(\n  input_simplified,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\nm_otley = tm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE) \n\n# Same for Armley:\ninput = sf::read_sf('data/rnet_armley.geojson')\ninput_projected = sf::st_transform(input, \"EPSG:27700\") \nif (!file.exists(\"data/input_simplified_armley.geojson\")) {\n  input_simplified = smplfy(input_projected, simplification_levels)\n  sf::write_sf(input_simplified, \"data/input_simplified_armley.geojson\", delete_dsn = TRUE)\n} else {\n  input_simplified = sf::read_sf('data/input_simplified_armley.geojson')\n}\ninput_simplified = left_join(\n  input_simplified,\n  simplification_df,\n  by = join_by(id == simp_factor)\n  )\nm_armley = tm_shape(input_simplified, bbox = tmaptools::bb(input_simplified, 1.1)) +\n  tm_lines() +\n  tm_facets(by = \"keep\", free.coords = TRUE)\n# m_otley\ntmap_arrange(m_otley, m_armley)\n\n\n\n\n\nFigure 4: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process.\n\n\n\n\n4.1.2 Network Simplification\nThe paper presents two approaches for network simplification: one involves image skeletonization, while the other utilizes Voronoi diagrams to identify central lines. The detailed steps of the methodology will be presented in the following sections.\n\n\n4.1.3 Create a projected combined buffered geometry:\nIn both approaches, the network simplification process initiates with the generation of buffered geometries, achieved using the get_geometry_buffer function. A buffer size of 8 meters is selected for this purpose. These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.\n\nfrom functools import partial\nfrom shapely import box\nfrom shapely.ops import voronoi_diagram, split\nfrom shapely import box, line_interpolate_point, snap\nfrom shapely.ops import voronoi_diagram\nimport geopandas as gp\nimport matplotlib.pyplot as plt\nfrom shapely import get_coordinates, line_merge, set_precision, unary_union\nfrom shapely.geometry import MultiPoint,MultiLineString,LineString,Point\nimport pandas as pd\nimport numpy as np\n\n\n\nplt.rcParams[\"figure.figsize\"] = (12, 12)\n\ndef get_geometry_buffer(this_gf, radius=8.0):\n    \"\"\"get_geometry_buffer: return radius buffered GeoDataFrame\n\n    args:\n      this_gf: GeoDataFrame to\n      radius: (default value = 8.0)\n\n    returns:\n      buffered GeoSeries geometry\n\n    \"\"\"\n    r = gp.GeoSeries(this_gf, crs=CRS).buffer(radius, join_style=\"round\", cap_style=\"round\")\n    union = unary_union(r)\n    try:\n        r = gp.GeoSeries(union.geoms, crs=CRS)\n    except AttributeError:\n        r = gp.GeoSeries(union, crs=CRS)\n    return r\n\nCRS = \"EPSG:27700\"\nbuffer_size = 8.0\nradius = buffer_size\n\ndef get_split(line, point, separation=1.0e-6):\n    return list(split(snap(line, point, separation), point).geoms)\n\nEMPTY = LineString([])\ndef split_ends(line, offset):\n    if line.length &lt;= 2.0 * offset:\n        return line, EMPTY, EMPTY\n    p = line_interpolate_point(line, offset)\n    head, centre = get_split(line, p)\n    p = line_interpolate_point(centre, -offset)\n    centre, tail = get_split(centre, p)\n    return head, centre, tail\n\n\nset_precision_pointone = partial(set_precision, grid_size=0.1)\nbase_otley = gp.read_file(\"./data/rnet_otley.geojson\").to_crs(CRS)\nbase_otley[\"geometry\"] = base_otley[\"geometry\"].map(set_precision_pointone)\notley_geometry = get_geometry_buffer(base_otley[\"geometry\"], radius=buffer_size)\n\n# Same for Armley:\nbase_armley = gp.read_file(\"./data/rnet_armley.geojson\").to_crs(CRS)\nbase_armley[\"geometry\"] = base_armley[\"geometry\"].map(set_precision_pointone)\narmley_geometry = get_geometry_buffer(base_armley[\"geometry\"], radius=buffer_size)\n\n\nsplit_end = partial(split_ends, offset=np.sqrt(1.5) * radius)\notley_split = pd.DataFrame(base_otley[\"geometry\"].map(split_end).to_list(), columns=[\"head\", \"centre\", \"tail\"])\narmley_split = pd.DataFrame(base_armley[\"geometry\"].map(split_end).to_list(), columns=[\"head\", \"centre\", \"tail\"])\n\n\nr = otley_split[[\"head\", \"tail\"]]\ntry:\n    r = gp.GeoSeries(list(unary_union(r.values).geoms), crs=CRS)\nexcept AttributeError:\n    r = gp.GeoSeries(list(unary_union(r.values)), crs=CRS)  \n\n#write_dataframe(r.to_frame(\"geometry\"), OUTPATH, layer=\"end\")\n## end\n#plot(r.to_frame(\"geometry\"), label=\"end\")\n## centre\nr = gp.GeoSeries(otley_split[\"centre\"], crs=CRS)\n#write_dataframe(r.to_frame(\"geometry\"), OUTPATH, layer=\"centre\")\n#plot(r.to_frame(\"geometry\"), label=\"centre\")\n\n#r = gp.GeoSeries(r, crs=CRS).buffer(radius, join_style=\"round\", cap_style=\"flat\", mitre_limit=1.0)\n#r = gp.GeoSeries(r, crs=CRS).buffer(radius, 0, join_style=\"round\", cap_style=\"flat\", mitre_limit=1.0)\nr = gp.GeoSeries(otley_split[\"centre\"], crs=CRS)\nr = gp.GeoSeries(r, crs=CRS).buffer(radius, 0, join_style=\"round\", cap_style=\"round\")\n#write_dataframe(r.to_frame(\"geometry\"), OUTPATH, layer=\"buffer2\")\n#plot(r.to_frame(\"geometry\"), colour=\"blue\")\n\n## overlapping\ncombined_nx = gp.GeoSeries(unary_union(r.values).geoms, crs=CRS)\n#write_dataframe(combined_nx.to_frame(\"geometry\"), OUTPATH, layer=\"buffer3\")\nr.plot()\n\n\n\n\nThe buffered versions of the networks are presented below:\n\n\n\n\nbase_otley.plot(edgecolor=\"blue\", color=\"blue\")\n\n\n\n\n\nbase_armley.plot(edgecolor=\"blue\", color=\"blue\")\n\n\n\n\n\n\n\notley_geometry.plot(edgecolor=\"black\", color=\"blue\")\n\n\n\n\n\narmley_geometry.plot(edgecolor=\"black\", color=\"blue\")\n\n\n\n\n\nFigure 5: Buffered versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n4.1.4 Skeletonization\nThe buffered lines are merged to create a raster image, which is then subjected to a thinning process to yield a skeletal remnant. This remnant retains both the extent and connectivity of the original network, centered around a line that aligns with the combined buffered region. This process is demonstrated using the Sample Street Network.\nEstablish an affine transformation that maps the points within the buffered geometry to corresponding positions in the raster image\nA scaled affine transformation is calculated to align the projected coordinate geometry with the corresponding scaled raster image.\n\nimport numpy as np\nimport pandas as pd\nimport rasterio as rio\nimport rasterio.features as rif\n\ndef get_pxsize(bound, scale=1.0):\n    \"\"\"get_pxsize: calculates scaled image size in px\n\n      bound: boundary corner points\n      scale: scaling factor (default = 1.0)\n\n    returns:\n      size in px\n\n    \"\"\"\n    r = np.diff(bound.reshape(-1, 2), axis=0)\n    r = np.ceil(r.reshape(-1))\n    return (r[[1, 0]] * scale).astype(int)\n\n\ndef get_affine_transform(this_gf, scale=1.0):\n    \"\"\"get_affine_transform: return affine transformations matrices, and scaled image size\n    from GeoPandas boundary size\n\n      this_gf: GeoPanda\n      scale:  (default = 1.0)\n\n    returns:\n      rasterio and shapely affine tranformation matrices, and image size in px\n\n    \"\"\"\n    TRANSFORM_ONE = np.asarray([0.0, 1.0, -1.0, 0.0, 1.0, 1.0])\n    bound = this_gf.total_bounds\n    s = TRANSFORM_ONE / scale\n    s[[4, 5]] = bound[[0, 3]]\n    r = s[[1, 0, 4, 3, 2, 5]]\n    r = rio.Affine(*r)\n    return r, s, get_pxsize(bound, scale)\n\nr_matrix, s_matrix, out_shape = get_affine_transform(otley_geometry, scale=2.0)\n\n\n\n4.1.5 Affine transforms\nThe affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0. The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation.\n\n4.1.5.1 Rasterio transform\n\nfrom IPython.display import display, Markdown\ndef display_matrix(matrix, header):\n    r = matrix.to_markdown(index=False, headers=header)\n    display(r)\n\nor_matrix = pd.DataFrame(np.asarray(r_matrix).reshape(-1, 3))\nos_matrix = pd.DataFrame(np.asarray(s_matrix).reshape(3, -1).T)\ndisplay_matrix(or_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0.5 |  0   | 426757 |\n| 0   | -0.5 | 437646 |\n| 0   |  0   |      1 |\n\n\n\n\n4.1.5.2 Shapely transform\n\ndisplay_matrix(os_matrix, \"   \")\n\n|     |      |        |\n|----:|-----:|-------:|\n| 0   | -0.5 | 426757 |\n| 0.5 |  0   | 437646 |\n\n\nIn these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation. The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.\n\n\n\n4.1.6 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image. This transformation adjusts the geometry to match the raster’s scale and orientation. Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles. This step ensures a more coherent and accurate representation in the raster image.\n\nimport warnings\n\nfrom skimage.morphology import remove_small_holes, skeletonize\nfrom shapely.affinity import affine_transform\nfrom shapely.geometry import Point\nimport rasterio.plot as rip\n\ngeometry_im = rif.rasterize(otley_geometry.values, transform=r_matrix, out_shape=out_shape)\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    geometry_im = remove_small_holes(geometry_im, 20).astype(np.uint8)\n\nrip.show(geometry_im, cmap=\"Blues\", title=\"buffer geometry\")\n\n\n\n\nThe image undergoes a thinning process, yielding a skeletal raster image as the result. This skeletonized image effectively captures the essential structure and layout of the original network.\n\nskeleton_im = skeletonize(geometry_im).astype(np.uint8)\npoint_im = np.stack(np.where(skeleton_im &gt;= 1))\nrip.show(skeleton_im, cmap=\"Blues\", title=\"skeleton geometry\")\n\n\n\nnx_point = gp.GeoSeries(map(Point, point_im.T), crs=CRS)\n\nThe rasterized skeletal image is then converted back into point geometry, completing the transformation process. The rasterized skeletal image is then converted back into point geometry, completing the transformation process.\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\ntransform_point = nx_point.map(shapely_transform).map(set_precision_pointone)\ntransform_point.plot(edgecolor=\"black\", color=\"blue\").grid()\nplt.show()\n\n\n\n\nThe challenge with this approach is that instead of generating points situated on the simplified network, it yields a mere set of points. What is required for effective analysis is a simplified set of line geometries, not just isolated points. This necessitates the inference of line geometry from the associated set of points.\n\n\n4.1.7 Transforming point geometry into line geometry\nTransforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.\nThe process of transforming point geometry into line geometry involves several key steps. Initially, the point set, derived from a skeletonized image, is analysed to identify adjacent points. Adjacency is determined based on proximity within the raster coordinate system, usually within a 1x1 pixel square.\nOnce adjacent points are identified, line segments are created by connecting these points. The final and crucial step is the amalgamation of these individual line segments. This combination results in a continuous line geometry that represents the simplified network structure. This conversion from point to line geometry is a pivotal aspect of network simplification.\n\nfrom shapely import get_coordinates\nfrom shapely.geometry import LineString, MultiLineString\n\ndef get_raster_line_with_knots(point):\n    \"\"\"get_raster_line_with_knots: return LineString GeoSeries from 1px line points with knots\n\n    args:\n      point: 1px point GeoSeries array with knots\n\n    returns:\n      1px line LineString GeoSeries with knots removed\n\n    \"\"\"\n    square = point.buffer(1, cap_style=\"square\", mitre_limit=1)\n    ix = point.sindex.query(square, predicate=\"covers\").T\n    ix = np.sort(ix)\n    s = pd.DataFrame(ix).drop_duplicates().reset_index(drop=True)\n    s = s.loc[np.where(s[0] != s[1])]\n    s = np.stack([point[s[0].values], point[s[1].values]]).T\n    r = gp.GeoSeries(map(LineString, s), crs=CRS)\n    edge, node = get_source_target(combine_line(r).to_frame(\"geometry\"))\n    return combine_line(edge[\"geometry\"])\n\ndef get_end(geometry):\n    \"\"\"get_end: return numpy array of geometry LineString end-points\n\n    args:\n      geometry: geometry LineString\n\n    returns:\n      end-point numpy arrays\n\n    \"\"\"\n    r = get_coordinates(geometry)\n    return np.vstack((r[0, :], r[-1, :]))\n\ndef get_source_target(line):\n    \"\"\"get_source_target: return edge and node GeoDataFrames from LineString with unique\n    node Point and edge source and target\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node: GeoDataFrames\n\n    \"\"\"\n    edge = line.copy()\n    r = edge[\"geometry\"].map(get_end)\n    r = np.stack(r)\n    node = gp.GeoSeries(map(Point, r.reshape(-1, 2)), crs=CRS).to_frame(\"geometry\")\n    count = node.groupby(\"geometry\").size().rename(\"count\")\n    node = node.drop_duplicates(\"geometry\").set_index(\"geometry\", drop=False)\n    node = node.join(count).reset_index(drop=True).reset_index(names=\"node\")\n    ix = node.set_index(\"geometry\")[\"node\"]\n    edge = edge.reset_index(names=\"edge\")\n    edge[\"source\"] = ix.loc[map(Point, r[:, 0])].values\n    edge[\"target\"] = ix.loc[map(Point, r[:, 1])].values\n    return edge, node\n\ndef combine_line(line):\n    \"\"\"combine_line: return LineString GeoSeries combining lines with intersecting endpoints\n\n    args:\n      line: mixed LineString GeoSeries\n\n    returns:\n      join LineString GeoSeries\n\n    \"\"\"\n    r = MultiLineString(line.values)\n    return gp.GeoSeries(line_merge(r).geoms, crs=CRS)\n\nnx_line = get_raster_line_with_knots(nx_point)\n\nTo visualize the simplified network in its original spatial context, it is necessary to apply the reverse affine transformation. This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework.\n\nshapely_transform = partial(affine_transform, matrix=s_matrix)\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.8 Knots\nKnots in the network often manifest as multiple short segments at intersections, resembling tangled knots.\nTo address these, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context.\n\nimport networkx as nx\nfrom shapely.geometry import MultiPoint\n\ndef get_raster_line_without_knot(this_line):\n    \"\"\"get_raster_line_without_knot: remove knots from LineString GeoSeries\n\n    args:\n      this_line: LineString GeoSeries array with knots\n\n    returns:\n      LineString GeoSeries with knots removed\n\n    \"\"\"\n    edge, node = get_source_target(this_line)\n    ix = edge.length &gt; 2.0\n    connected = get_connected_class(edge.loc[~ix, [\"source\", \"target\"]])\n    node = node.loc[connected.index].join(connected).sort_index()\n    connected_edge = get_centre(node)\n    r = combine_line(pd.concat([connected_edge[\"geometry\"], edge.loc[ix, \"geometry\"]]))\n    return r[r.length &gt; 2.0]\n\n\ndef get_connected_class(edge):\n    \"\"\"get_connected_class: return labeled connected node pandas Series from edge list\n\n    args:\n      edge_list: source, target edge pandas DataFrame\n\n    returns:\n      labeled node pandas Series\n\n    \"\"\"\n    nx_graph = nx.from_pandas_edgelist(edge)\n    connected = nx.connected_components(nx_graph)\n    r = {k: i for i, j in enumerate(connected) for k in j}\n    return pd.Series(r, name=\"class\")\n\ndef get_centre(node):\n    \"\"\"get_centre_edge: return centroid Point from discrete node clusters\n\n    args:\n      node: discrete node cluster GeoDataSeries\n\n    returns:\n      GeoDataCentre node cluster centroid Point\n\n    \"\"\"\n    centre = node[[\"geometry\", \"class\"]].groupby(\"class\").aggregate(tuple)\n    centre = gp.GeoSeries(centre[\"geometry\"].map(MultiPoint), crs=CRS).centroid\n    centre = centre.rename(\"target\")\n    geometry = node[[\"class\", \"geometry\"]].set_index(\"class\").join(centre)\n    geometry = geometry.apply(LineString, axis=1)\n    r = node.rename(columns={\"node\": \"source\"}).copy()\n    r[\"geometry\"] = geometry.values\n    return r\n\n\nnx_line = get_raster_line_without_knot(nx_line.to_frame(\"geometry\"))\nnx_output = nx_line.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()\n\n\n\n\n\n\n4.1.9 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points.\n\ndef get_nx(line):\n    \"\"\"get_nx: return primal edge and node network from LineString GeoDataFrame\n\n    args:\n      line: LineString GeoDataFrame\n\n    returns:\n      edge, node GeoDataFrames\n\n    \"\"\"\n    r = line.map(get_end)\n    edge = gp.GeoSeries(r.map(LineString), crs=CRS)\n    r = np.vstack(r.to_numpy())\n    r = gp.GeoSeries(map(Point, r)).to_frame(\"geometry\")\n    r = r.groupby(r.columns.to_list(), as_index=False).size()\n    return edge\n\n\nnx_edge = get_nx(nx_line)\nnx_output = nx_edge.map(shapely_transform).map(set_precision_pointone)\nnx_output.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#simplification-via-voronoi-polygons",
    "href": "index.html#simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via voronoi polygons",
    "text": "4.2 Simplification via voronoi polygons\nIn this approach, the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a center-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n4.2.1 Boundary\nThe get_geometry_line funtion is defined to convert a given geometry into a simplified LineString boundary. The function first extracts the boundary of the input geometry and then simplifies it using a set tolerance level. The result is a GeoSeries of the simplified LineString, correctly aligned with a specified coordinate reference system (CRS). This functionality is particularly useful in geographic information systems (GIS) for delineating and visualizing precise boundaries of spatial objects. The code demonstrates its utility by applying the function to a geometry (otley_geometry) and visualizing the resultant simplified boundaries (nx_boundary), highlighting its practical application in spatial analysis and network simplification.\n\nfrom shapely import box\nfrom shapely.ops import voronoi_diagram\n\nscale = 5.0\ntolerance=1.0\n\ndef get_geometry_line(this_buffer):\n    \"\"\"get_geometry_line: returns LineString boundary from geometry\n\n    args:\n      this_buffer: geometry to find LineString\n\n    returns:\n       simplified LineString boundary\n    \"\"\"\n    r = this_buffer.boundary.explode(index_parts=False).reset_index(drop=True)\n    return gp.GeoSeries(r.simplify(tolerance=0.5), crs=CRS)\n\nnx_boundary = get_geometry_line(otley_geometry)\nnx_boundary.plot()\nplt.show()\n\n\n\n\n\n\n4.2.2 Segment\nThe simplified LineString geometries are then broken down into shorter segments.\n\ndef get_segment_nx(line, scale):\n    \"\"\"get_segment_nx: segment line into sections, no more than scale long\n\n    args:\n      line:  line to segment\n      scale: length to segment line\n\n    returns:\n      segmented LineStrings\n\n    \"\"\"\n    set_segment = partial(get_segment, distance=scale)\n    r = line.map(set_segment).explode().rename(\"geometry\")\n    return gp.GeoDataFrame(r, crs=CRS)\n\ndef get_linestring(line):\n    \"\"\"get_linestring: return LineString GeoSeries from line coordinates\n\n    args:\n      line:\n\n    returns:\n       LineString GeoSeries\n    \"\"\"\n    r = get_coordinates(line)\n    r = np.stack([gp.points_from_xy(*r[:-1].T), gp.points_from_xy(*r[1:].T)])\n    return gp.GeoSeries(pd.DataFrame(r.T).apply(LineString, axis=1), crs=CRS).values\n\ndef get_segment(line, distance=50.0):\n    \"\"\"get_segment: segment LineString GeoSeries into distance length segments\n\n    args:\n      line: GeoSeries LineString\n      length: segmentation distance (default value = 50.0)\n\n    returns:\n      GeoSeries of LineStrings of up to length distance\n\n    \"\"\"\n    return get_linestring(line.segmentize(distance))\n\nnx_segment = get_segment_nx(nx_boundary, scale).reset_index(drop=True)\nnx_segment.plot(edgecolor=\"red\", linestyle='--', linewidth=1)\nplt.show()\n\n\n\n\n\n\n4.2.3 Point\nThe simplified LineString geometries are converted into point geometries.\n\nnx_point = nx_segment.loc[:, \"geometry\"].map(get_coordinates).explode()\nnx_point = MultiPoint(nx_point[::2].map(Point).values)\nnx_output = gp.GeoSeries(nx_point, crs=CRS)\nnx_output.plot(edgecolor=\"blue\", color=\"white\")\nplt.show()\n\n\n\n\n\n\n4.2.4 Voronoi\nThe Voronoi diagram is generated from nx_point within the bounds of nx_envelope.\n\nnx_envelope = box(*nx_point.bounds)\nnx_voronoi = voronoi_diagram(nx_point, envelope=nx_envelope, tolerance=tolerance, edges=True)\nnx_voronoi = gp.GeoSeries(map(set_precision_pointone, nx_voronoi.geoms), crs=CRS)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.5 Voronoi 2\n\nnx_voronoi = nx_voronoi.explode(index_parts=False).clip(nx_envelope)\nix = ~nx_voronoi.is_empty & (nx_voronoi.type == \"LineString\")\nnx_voronoi = nx_voronoi[ix].reset_index(drop=True)\nnx_voronoi.plot()\nplt.show()\n\n\n\n\n\n\n4.2.6 Voronoi simplified network\n\ndef get_voronoi_line(voronoi, boundary, geometry, buffer_size):\n    \"\"\"get_voronoi_line: returns cleaned simplified line by filtering Voronoi lines by distance,\n    contained within network buffer Polygons, and combining overlapping end-points\n\n    args:\n      voronoi:     Voronoi LineString\n      boundary:    network buffer LineString\n      geometry:    network buffer Polygon\n      buffer_size: network buffer distance [m]\n\n    returns:\n      simplified simplified network line\n\n    \"\"\"\n    offset = buffer_size / 2.0\n    r = filter_distance(voronoi, boundary, offset)\n    r = filter_buffer(r, geometry)\n    edge, node = get_source_target(r.to_frame(\"geometry\"))\n    ix = node[\"count\"] &lt; 4\n    square = node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\n    square = gp.GeoSeries(unary_union(square.values).geoms, crs=CRS)\n    r = edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\n    r = set_geometry(r, square)\n    return combine_line(r)\n\ndef filter_distance(line, boundary, offset):\n    \"\"\"filter_distance: filter line closer than distance offset from boundary\n\n    args:\n      line:     LineStrings to simplify\n      boundary: boundary LineString\n      offset:\n\n    returns:\n      simplified LineStrings\n    \"\"\"\n    edge, _ = get_source_target(line.to_frame(\"geometry\"))\n    (ix, _), distance = boundary.sindex.nearest(edge[\"geometry\"], return_distance=True)\n    _, ix = np.unique(ix, return_index=True)\n    ix = distance[ix] &gt; offset\n    return combine_line(edge.loc[ix, \"geometry\"]).simplify(1.0)\n\ndef filter_buffer(line, geometry):\n    \"\"\"filter_buffer: filter keeping lines within boundary Polygon\n\n    args:\n      line:     LineStrings to simplify\n      geometry: boundary Polygon\n\n    returns:\n      filtered LineStrings\n    \"\"\"\n    (_, ix) = line.sindex.query(geometry, predicate=\"contains_properly\")\n    return combine_line(line.loc[ix]).simplify(1.0)\n\ndef set_geometry(line, square):\n    \"\"\"set_geometry: return LineString simplified by combining overlapping end-points\n\n    args:\n      line:     LineStrings to simplify\n      square:   overlapping squares\n\n    returns:\n      simplified LineStrings\n\n    \"\"\"\n    r = line.reset_index(drop=True)\n    centroid = square.centroid.map(set_precision_pointone).set_crs(CRS)\n    edge, node = get_source_target(r)\n    ix = node[\"geometry\"].sindex.query(square, predicate=\"contains_properly\")\n    node.loc[ix[1], \"geometry\"] = centroid[ix[0]].values\n    source = node.loc[edge[\"source\"], \"geometry\"].values\n    target = node.loc[edge[\"target\"], \"geometry\"].values\n    r = np.stack([source, target]).T\n    return gp.GeoSeries(map(LineString, r), crs=CRS)\n\n#nx_line = get_voronoi_line(nx_voronoi, nx_boundary, otley_geometry, buffer_size)\n\noffset = buffer_size / 2.0\nnx_line = filter_distance(nx_voronoi, nx_boundary, offset)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.7 Voronoi line\n\nnx_line = filter_buffer(nx_line, otley_geometry)\nnx_edge, nx_node = get_source_target(nx_line.to_frame(\"geometry\"))\nix = nx_node[\"count\"] &lt; 4\nnx_square = nx_node[ix].buffer(offset, cap_style=\"square\", mitre_limit=offset)\nnx_square = gp.GeoSeries(unary_union(nx_square.values).geoms, crs=CRS)\nnx_line = nx_edge[\"geometry\"].map(get_linestring).explode().to_frame(\"geometry\")\nnx_line = set_geometry(nx_line, nx_square)\nnx_line = combine_line(nx_line)\nnx_line.plot()\nplt.show()\n\n\n\n\n\n\n4.2.8 Primal network\n\nnx_edge = get_nx(nx_line)\nnx_edge.plot()\nplt.show()"
  },
  {
    "objectID": "index.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "href": "index.html#integrating-attributes-from-the-detailed-network-into-the-simplified-network",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Integrating attributes from the detailed network into the simplified network",
    "text": "4.3 Integrating attributes from the detailed network into the simplified network\nIn instances where a simplified version of the network is readily available, such as OS Open Roads, the steps for network simplification can be bypassed. Instead, the focus shifts to integrating attributes from the detailed network into the simplified network. This approach streamlines the process, leveraging pre-existing simplified network data while enriching it with detailed attributes.\nIn this section, we focus on integrating attributes from a detailed route network into a simplified one. We achieve this using the stplanr package in R, a powerful tool designed specifically for transport planning. stplanr emphasizes spatial transport data and is particularly adept at handling non-motorized modes of transportation. More about stplanr can be found on its CRAN page [] (https://cran.r-project.org/web/packages/stplanr/index.html).\nData Preparation:\nThe core functionality of our integration process hinges on two pivotal inputs: rnet_x and rnet_y. Each plays a distinct yet complementary role in the network attribute integration:\n\nrnet_x - Target Route Network: This dataset represents our base framework. It is a streamlined, simplified version of a more intricate network, serving as the foundational geometry. rnet_x is akin to a canvas, prepared to receive additional layers of data. It wroth to note that rnet_x need to contian a identifier columns.\nrnet_y - Source of Additional Attributes: In contrast to rnet_x, rnet_y brings depth and detail. It is the repository of rich, comprehensive attributes that are waiting for transfer to our target network.\n\nStep 1: Coordinate Reference System Alignment\nTransform the spatial data of both rnet_x (the simplified network) and rnet_y (the detailed network) to the same coordinate reference system. For this project, we have selected EPSG:27700.\n\nrnet_xp = sf::st_transform(rnet_x, \"EPSG:27700\")\nrnet_yp = sf::st_transform(rnet_y, \"EPSG:27700\")\n\nStep 2: Defining the Function List\nCreate a function list that dictates how each attribute is to be processed:\n\nExclude: “geometry” from processing.\nMean Function: Applied to attributes like “Gradient” and “Quietness”. TODO expline the funtion of sum and mean\nSum Function: Used for aggregating values in columns such as “all_bicycle”.\n\nStep 3: Using stplanr::rnet_merge for Integration\nEmploy the rnet_merge function from the stplanr package. This function is designed to merge route network data, taking into account the predefined functions and alignment in the coordinate system.\n\nrnet_merged = stplanr::rnet_merge(rnet_xp, rnet_yp, dist = 20, segment_length = 10, funs = funs, max_angle_diff = 30) \n\nIn the example code, four arguments need to be carefully defined:\n\ndist (Buffer Distance): This parameter defines the buffer zone around rnet_xp in meters, essential for determining the proximity at which features from both networks are considered for merging. Typically, this value is refined to approximate the width of streets, ensuring a realistic spatial correlation between the network elements.\nsegment_length (Segment Maximum Length): This specifies the upper limit for each segment’s length within the detailed network, here set to 10 meters. Segmenting the network in this manner enhances manageability and contributes to more precise localization of lines within the specified buffer. This granularity is key for achieving higher accuracy in attribute integration.\nfuns (Function List): Comprises a series of functions assigned to process each attribute during the merge. This may involve applying statistical operations, such as calculating the mean or sum of various attributes. The choice of function for each attribute is determined based on the nature of the data and the specific analytical requirements.\nmax_angle_diff (Maximum Angular Difference): This parameter is crucial in regulating the maximum allowable angular deviation between segments and target lines during the merging process. With a set threshold of 20 degrees, it ensures that merging is confined to segments with similar orientations. Such consideration of angular alignment plays a pivotal role in maintaining the network’s geometric integrity. It notably helps in preventing inappropriate attribute transfers, such as avoiding the assignment of values from a road that is perpendicular to another, like in T junction scenarios. By enforcing this restriction on angular differences, the integrity and coherence of the route network’s structure are preserved, ensuring the merged network accurately reflects the true spatial layout and connectivity of the routes.\n\n\n\nrnet_xp = st_transform(rnet_x, \"EPSG:27700\")\nrnet_yp = st_transform(rnet_y, \"EPSG:27700\")\n\n# Extract column names from the rnet_yp\nname_list = names(rnet_yp)\n\n# Initialize an empty list\nfuns = list()\n\n# Loop through each name and assign it a function based on specific conditions\nfor (name in name_list) {\n  if (name == \"geometry\") {\n    next  # Skip the current iteration\n  } else if (name %in% c(\"Gradient\", \"Quietness\")) {\n    funs[[name]] = mean\n  } else {\n    funs[[name]] = sum\n  }\n}\n\ndist = 20\nrnet_merged_with_angle = stplanr::rnet_merge(rnet_xp, rnet_yp, dist = dist, segment_length = 10, funs = funs, max_angle_diff = 20)\nrnet_merged_without_angle= stplanr::rnet_merge(rnet_xp, rnet_yp, dist = dist, segment_length = 10, funs = funs)\n\n# Define breaks for the color scale\nbrks = c(0, 100, 500, 1000, 5000)\n\n# Set global tmap options for tighter margins\ntmap_options(\n  outer.margins = c(0, 0, 0, 0),\n  inner.margins = c(0, 0, 0, 0)\n)\n\n# Create the first map with scale bar\nm1 = tm_shape(rnet_merged_with_angle) + \n     tm_lines(\"value\", palette = \"viridis\", lwd = 5, breaks = brks) +\n     tm_scale_bar() +\n     tm_layout(frame = FALSE, inner.margins = 0, outer.margins = 0, asp = 0)\n\n# Create the second map\nm2 = tm_shape(rnet_merged_without_angle) + \n     tm_lines(\"value\", palette = \"viridis\", lwd = 5, breaks = brks) +\n     tm_layout(frame = FALSE, inner.margins = 0, outer.margins = 0, asp = 0)\n\n# Arrange the two maps vertically with a tight layout and synchronization\ntmap_arrange(m1, m2, nrow = 2, sync = TRUE)\n\n\n\n\nOnce we obtained the rnet_merged dataset, which is a simplified network but also contains detailed attributes, we then need a series of steps to refine the data:\n\nCleaning: The rnet_merged dataset undergoes an initial cleaning phase where superfluous columns are removed. This step enhances dataset manageability and focuses on relevant data by eliminating columns such as ‘identifier’ and ‘length_x’.\nDimensionality Reduction: Z and M dimensions are removed from the dataset, as they are redundant for our analysis and contribute to unnecessary increases in file size. This reduction simplifies the dataset and optimizes it for storage and processing efficiency.\nNA Handling: A thorough examination is conducted for the presence of NA values across the columns. Any rows where all the targeted columns contain NA values are filtered out.\nSpatial Subsetting: Following the removal of linestrings that contain NA attributes from the rnet_merged dataset, we proceed to create a geometric buffer zone. This zone serves as a spatial criterion for identifying and retaining only those geometries that lie outside of this buffer. A subset of rnet_yp, termed rnet_yp_rest, is then delineated based on this spatial relationship, effectively omitting any geometries that intersect with or fall within the buffered area. This step ensures that only those components of rnet_y which are spatially distinct from rnet_merged are retained for further consideration.\nNetwork Simplification: In the final stage of simplification, the datasets rnet_yp_rest and rnet_merged_all are combined to form the final network, which retains the simplicity of the original simplified structure while concurrently encompassing the detailed attributes, thereby providing a comprehensive yet efficient foundation for further analysis.\n\nBy meticulously following these steps, we ensure that the integration of attributes is not only accurate but also tailored to the specific needs of our analysis.\n\nrnet_x = gp.read_file(\"https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_x_ed.geojson\")\nrnet_y = gp.read_file(\"https://github.com/ropensci/stplanr/releases/download/v1.0.2/rnet_y_ed.geojson\")\n# Plotting both GeoJSON files side by side\nfig, axes = plt.subplots(1, 2, figsize=(15, 8))\n\nrnet_x.plot(ax=axes[0], color='blue')\naxes[0].set_title('RNet X')\n\nrnet_y.plot(ax=axes[1], color='green')\naxes[1].set_title('RNet Y')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation of the SUMO traffic simulation tool for an example of the wide range of data formats that transport datasets can output.↩︎"
  }
]