[
  {
    "objectID": "paper.html",
    "href": "paper.html",
    "title": "Route network simplification for transport planning",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render paper.qmd\nInstall the dependencies by cloning the repository and running the following:\n\n\nRcppEigen (0.3.4.0.0 -&gt; 0.3.4.0.1) [CRAN]\n\n\nInstalling pyenv ...\nDone! pyenv has been installed to '/home/runner/.local/share/r-reticulate/pyenv/bin/pyenv'.\n\n\n[1] \"/home/runner/.pyenv/versions/3.12.4/bin/python3.12\"\n\n\nUsing Python: /home/runner/.pyenv/versions/3.12.4/bin/python3.12\nCreating virtual environment '~/.virtualenvs/r-reticulate' ... \nDone!\nInstalling packages: pip, wheel, setuptools\nVirtual environment '~/.virtualenvs/r-reticulate' successfully created.\nUsing virtual environment '~/.virtualenvs/r-reticulate' ...\n\n\nTo contribute to the papers written as quarto documents (with .qmd extensions) like this one, we recommend using the Quarto extension for VS Code. You can go into the visual editor with the following shortcut:\nCtrl+Shift+F4\nYou can then add citations with Ctrl+Shift+F11 and benefit from Quarto’s other features for academic writing."
  },
  {
    "objectID": "paper.html#sec-topology-preserving-simplification",
    "href": "paper.html#sec-topology-preserving-simplification",
    "title": "Route network simplification for transport planning",
    "section": "4.1 Topology-preserving simplification",
    "text": "4.1 Topology-preserving simplification\nTopology-preserving simplification reduces the number of vertices in a linestring while preserving the topology of the network. As shown in top panel of Figure 4, topology-preserving simplication can reduce the number of edges, but fails to merge parallel lines in complex geometries, as shown in the the bottom panel in Figure 4.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Illustration of topology-preserving simplification, using the mapshaper JavaScript package. The % values represent the “percentage of removable points to retain” argument values used in the simplification process."
  },
  {
    "objectID": "paper.html#sec-simplification-via-skeletonization",
    "href": "paper.html#sec-simplification-via-skeletonization",
    "title": "Route network simplification for transport planning",
    "section": "4.2 Simplification via skeletonization",
    "text": "4.2 Simplification via skeletonization\nIn the skeletonization approach a simplified network is generated by buffering the line-network, applying an image skeletonization algorithm and extracting lines segements from a raster of this buffer.\n\n4.2.1 Create a projected combined buffered geometry:\nIn both the skeletonization and Voronoi approaches, the network simplification process starts with the generation of buffered geometries, achieved using the get_geometry_buffer function. For our purposes, we have chosen a buffer size of 8 meters. These buffered geometries are essential for spatial analyses as they extend the influence area of each geometry, thereby facilitating the identification and processing of geometries that intersect or lie adjacent to each other in subsequent stages of the analysis.\nFigure 5 displays the buffered versions of the Otley Road (on the left) and Armley Road (on the right) networks. It visually illustrates how the application of an 8-meter buffer transforms the initial geometries of these roads. This representation is pivotal for understanding the spatial extension and the overlapping areas created by the buffer zones around each road network, setting the stage for subsequent analysis and simplification processes​.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Buffered versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nIn Figure 6, truncated and segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks are presented. This visualization demonstrates the process of cutting and segmenting the buffer geometries. It highlights the transformations from the initial buffered geometries to a more segmented and manageable form, preparing them for further analysis and simplification steps​.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Truncated and segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nFigure 7 shows the segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks. It effectively highlights the contrast between the more intricate and the simpler sections within these networks.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Segmented buffer geometries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n\n4.2.2 Skeletonization\nIn the skeletonization process, the buffered lines of the network are first transformed into a raster image. Subsequently, this raster image is processed through a thinning algorithm to produce a skeletal representation of the original network. This skeletal structure preserves the overall extent and connectivity of the initial network, with a central line that closely follows the contours of the combined buffered area.\nTo correlate the points in the buffered geometry with their respective positions in the raster image, we implement an affine transformation. This transformation is scaled to ensure that the projected coordinate geometry of the network aligns accurately with the corresponding dimensions of the scaled raster image. Through this process, we maintain the spatial integrity and relational positioning of the network elements within the simplified raster format.\n\n\n4.2.3 Affine transforms\nThe affine transformations for Rasterio and Shapely are demonstrated with a scaling factor of 2.0. The Rasterio transform applies a scale and translation in a specific order, while the Shapely transform follows a different order for scaling and rotation, as illustrated in Table Table 2.\n\n\n\nTable 2: Rasterio and Shapely affine transformation matrices for the Otley Road network.\n\n\n\n\n\n\n\n(a) Rasterio affine transformation matrix.\n\n\n\n\n\n0.5\n0\n426757\n\n\n0\n-0.5\n437646\n\n\n0\n0\n1\n\n\n\n\n\n\n\n\n\n\n\n(b) Shapely affine transformation matrix.\n\n\n\n\n\n0\n-0.5\n426757\n\n\n0.5\n0\n437646\n\n\n\n\n\n\n\n\n\n\n\nIn these matrices, the first two columns represent the scaling and rotation components, while the last column represents the translation. The Rasterio transform matrix first scales the coordinates by 0.5 and then translates them, whereas the Shapely transform first rotates the coordinates and then applies the scaling.\n\n\n4.2.4 Skeletonize the buffer to a point geometry\nA scaled affine transformation is applied to align the projected coordinate geometry with the scaled raster image. This transformation adjusts the geometry to match the raster’s scale and orientation. Following this, the raster image undergoes a cleaning process to eliminate small holes that often appear in areas where buffered lines run parallel or intersect at shallow angles, resulting in raster representations illustrated in Figure 8. This step ensures a more coherent and accurate representation in the raster image.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Rasterized versions of the Otley Road (left) and Armley Road (right) networks, with post processing to remove small holes.\n\n\n\nThe image undergoes a thinning process, yielding a skeletal raster image as the result. This skeletonized image effectively captures the essential structure and layout of the original network, as illustrated in Figure 9.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 9: Skeletonized versions of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nThe rasterized skeletal image is then converted back into point geometry, completing the vector -&gt; raster -&gt; vector geometry transformation process.\n\n\n\nThe challenge with this approach is that instead of generating points situated on the simplified network, it returns a set of points rather than line geometries. This necessitates the inference of line geometry from the associated set of points. Transforming a skeletonized point set into a simplified line geometry is arguably the most complex step in creating a simplified network.\nThe process of transforming point geometry into line geometry involves identifying adjacent points based on proximity within the raster coordinate system, usually within a 1x1 pixel square. After adjacent points are identified, line segments are created by connecting these points. The final and crucial step is the amalgamation of these individual line segments. This combination results in a continuous line geometry that represents the simplified network.  To visualize the simplified network in its original spatial context, the reverse affine transformation is applied. This step reverts the network back to its original coordinate system, aligning the simplified geometry with the original spatial framework. The resulting simplified network is illustrated in Figure 10.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 10: Simplified versions of the Otley Road (left) and Armley Road (right) networks, transformed back into line geometry."
  },
  {
    "objectID": "paper.html#sec-simplification-via-voronoi-polygons",
    "href": "paper.html#sec-simplification-via-voronoi-polygons",
    "title": "Route network simplification for transport planning",
    "section": "4.3 Simplification via Voronoi polygons",
    "text": "4.3 Simplification via Voronoi polygons\nIn this approach, the network lines are first buffered as described above. The edges of these buffers are then segmented into sequences of points. From these sequences, a centre-line is derived based on a set of Voronoi polygons that cover these points. This approach facilitates the creation of a simplified network representation by focusing on the central alignment of the buffered lines.\n\n4.3.1 Boundary Segmentation\nIn Figure 11, the boundary of the buffered input geometry (otley_geometry) is calculated and then simplified. This process yields a simplified GeoSeries consisting of LineStrings, all of which are precisely aligned with the specified coordinate reference system (CRS). This step illustrates the transformation from the initial buffer geometries, named ‘otley_buffer’ and ‘Armley_buffer’, to their more refined and simplified versions, ‘otley_boundary’ and ‘Armley_boundary’, respectively. These refined boundaries provide an accurate representation and visualization of the exact limits of the spatial objects involved.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 11: Simplified boundaries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nFigure 12 showcase the conversion of segmented LineString geometries into point geometries. This essential transformation forms the basis for constructing Voronoi diagrams.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Detail segmented boundaries of the Otley Road (left) and Armley Road (right) networks.\n\n\n\nFigure 13, the process of converting the segmented LineString geometries into point geometries is illustrated. This transformation is essential for the creation of Voronoi diagrams.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 13: Detail point segement of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\n\n\n4.3.2 Voronoi diagram\nIn Figure 14, the generation and clipping of the corresponding Voronoi diagrams to the bounds of the input geometry is depicted.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Clipped Voronoi diagrams of the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\nFigure 15 shows the Voronoi lines that are completely enclosed within the buffer geometry and are situated at a distance of less than half the buffer’s width from the buffer edge. This selective visualization of Voronoi lines effectively demonstrates the method precision in capturing and representing the central alignment of the transport network within its buffered confines.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 15: Voronoi diagram lines with lines that are completely within the buffer geometry and less than half-a-buffer-width from the buffer edge.\n\n\n\n\n\n4.3.3 Voronoi simplified network\nThe center-line network depicted in Figure 16 is created through a process that involves the removal of knot-like features from the resultant network. This step refines the geometry of network, ensuring a more streamlined and accurate representation of the transport routes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 16: Simplified versions of the Otley Road (left) and Armley Road (right) networks."
  },
  {
    "objectID": "paper.html#post-processing",
    "href": "paper.html#post-processing",
    "title": "Route network simplification for transport planning",
    "section": "4.4 Post-Processing",
    "text": "4.4 Post-Processing\nBoth skeletonization and Voronoi simplified networks require post-processing to remove unwanted knots. Optionally by removing intermediate lines-sections, a further simplified or primal network that captures the essential connectivity and layout of transport routes can be generated.\n\n4.4.1 Knots\nKnots in the network are multiple short segments at intersections, resembling tangled knots. To remove these features of networks, which add complexity that is rarely relevant for strategic transport planning, short segments are clustered together, and a central point for each cluster is determined. The end-points of longer lines that connect to these segment clusters are then realigned to the cluster’s central point. This process effectively removes the knot-like appearance. As with previous steps, the reverse affine transformation is applied to the simplified network before plotting, ensuring the network is represented in its original spatial context, as illustrated in Figure 17.\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 17: Zoomed in versions of road structure with knots (left), and with knots removed (right) shown in Figure 17.\n\n\n\n\n\n4.4.2 Primal network\nThere are circumstances where it might be beneficial to view a “primal” network, which is exclusively composed of direct lines connecting start and end points. This primal network represents an extreme form of simplification, of great potential value in situations in which the network’s overall structure and compression ratios are priorities.\nThe primal networks for the Otley Road and Armley Road skeletonized networks are illustrated in Figure 18.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 18: Primal skeletonized networks for the Otley Road (left) and Armley Road (right) networks.\n\n\n\n\nFigure 19 illustrates the primal network derived from the Voronoi approach.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 19: Primal Voronoi networks for the Otley Road (left) and Armley Road (right) networks."
  },
  {
    "objectID": "paper.html#sec-joining-route-networks",
    "href": "paper.html#sec-joining-route-networks",
    "title": "Route network simplification for transport planning",
    "section": "4.5 Joining route networks",
    "text": "4.5 Joining route networks\nAfter generating a simplified network using the methods described in the previous sections or through an alternative approach, the next crucial step involves transferring attribute values from the detailed network to the simplified one. This process is commonly referred to as ‘conflation’ and ‘integration’. Conflation is essential because while the source file (detailed network) might be rich in attributes like street names, address ranges, and zip codes, it may lack positional accuracy. Conversely, the target file (simplified network) is likely to be positionally precise but deficient in detailed attributes. As noted by (Sutton 1998), network data integration encompasses two key aspects: the geometric integration, involving the link and node feature elements, and the integration of attributes such as highway data. In our context, the purpose of the joining stage is to merge the detailed attributes from the source network onto the geometrically simplified target network. This ‘joining’ step is vital for using simplified networks as the basis for presenting model outputs generated on a complex network in a easy-to-interpret form. \nThe process is analogous to joining two datasets based on a common ‘key’ variable. In this case there is no definitive key, meaning that network joining can be regarded as a ‘fuzzy’ or ‘keyless’ join process (Suri et al., n.d.; Wachowicz and Mrozek 2019): as with the network simplification steps outlined above, the user must select joining parameters to maximise the accuracy of the join. The simplified (typically denoted ‘x’) object can also be referred to as the ‘target’ object, following the terminology used to describe database and ‘spatial similarity’ joins (Ballesteros, Cary, and Rishe 2011). There are at least a couple of implementations of network joining approaches in open source software: the rnet_merge() function in the stplanr R package (Lovelace, Ellison, and Morgan 2019), and the rnetmatch Rust crate which has binding to R and (soon) Python. The details of network joining methods, algorithms and implementations are outside the scope of this paper, see the documentation associated with the projects mentioned above for more information."
  },
  {
    "objectID": "paper.html#discussion",
    "href": "paper.html#discussion",
    "title": "Route network simplification for transport planning",
    "section": "6.1 Discussion",
    "text": "6.1 Discussion\nThe results obtained from applying these methods have highlighted several key insights. First, the importance of maintaining the integrity and topological accuracy of the original network in the simplification process cannot be overstated. Both methods successfully reduced the complexity of the network representations while preserving essential spatial and connectivity characteristics. This balance is crucial for ensuring that the simplified networks remain true to their real-world counterparts, thus maintaining the reliability of transport planning models and decisions based on these models.\nFurthermore, the comparative analysis of the two methods revealed their respective strengths and potential applications. The image skeletonization approach excelled in producing more streamlined network representations, particularly effective in contexts where a high-level overview of the network is required. On the other hand, the Voronoi diagram-centreline identification method provided a more nuanced simplification, capturing the central alignment of the route networks, making it suitable for detailed analysis and planning at a more granular level."
  },
  {
    "objectID": "paper.html#conclusion",
    "href": "paper.html#conclusion",
    "title": "Route network simplification for transport planning",
    "section": "6.2 Conclusion",
    "text": "6.2 Conclusion\nConclusively, the study underscores the significance of route network simplification in the transport planning. The methodologies tackle the increasing intricacy of urban route networks. By simplifying these networks, we can achieve more efficient and actionable insights for urban transport planning. This not only aids in better visualization and interpretation of transport models but also harmonizes the complexity of urban networks with the clarity needed for effective planning and decision-making."
  },
  {
    "objectID": "paper.html#footnotes",
    "href": "paper.html#footnotes",
    "title": "Route network simplification for transport planning",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee the online documentation.↩︎"
  },
  {
    "objectID": "cookbook.html",
    "href": "cookbook.html",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "",
    "text": "To reproduce this paper you need quarto installed.\nAfter installing the dependencies, you can reproduce the paper by running the following command in the terminal:\nquarto render cookbook.qmd"
  },
  {
    "objectID": "cookbook.html#create-a-working-directory",
    "href": "cookbook.html#create-a-working-directory",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.1 Create a working directory",
    "text": "2.1 Create a working directory\nOpen a shell command line prompt and type:\n$ mkdir elegant-tern\n$ cd elegant-tern"
  },
  {
    "objectID": "cookbook.html#create-and-activate-python3-virtual-environment",
    "href": "cookbook.html#create-and-activate-python3-virtual-environment",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.2 Create and activate python3 virtual-environment",
    "text": "2.2 Create and activate python3 virtual-environment\nCreate a python virtual environment under venv in the working directory:\n$ python3 -m venv venv\n$ source venv/bin/activate\nActivation then means that the scripts and modules installed in the virtual environment are added to the shell execution path."
  },
  {
    "objectID": "cookbook.html#upgrade-the-base-pip-and-wheel-modules-optional",
    "href": "cookbook.html#upgrade-the-base-pip-and-wheel-modules-optional",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.3 Upgrade the base pip and wheel modules (optional)",
    "text": "2.3 Upgrade the base pip and wheel modules (optional)\nThis is to make sure you are working with the lastest version of the python3 package management and installation tools:\n$ pip install --upgrade pip\n$ pip install --upgrade wheel\nThis becomes more important if you are maintaining a pypi project."
  },
  {
    "objectID": "cookbook.html#install-the-parenx-project",
    "href": "cookbook.html#install-the-parenx-project",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.4 Install the parenx project:",
    "text": "2.4 Install the parenx project:\nThis installs the latest release of the parenx scripts from pypi and prints the module version to stdout:\n$ pip install parenx\n$ python3 -c \"import parenx; from importlib.metadata import version; print(version('parenx'))\"\n0.5.6"
  },
  {
    "objectID": "cookbook.html#simplify-a-linear-network",
    "href": "cookbook.html#simplify-a-linear-network",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.5 Simplify a linear-network",
    "text": "2.5 Simplify a linear-network\nTo simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\n$ skeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg"
  },
  {
    "objectID": "cookbook.html#notes",
    "href": "cookbook.html#notes",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "2.6 Notes",
    "text": "2.6 Notes\nWhile there are many different takes and system to manage python packages, my experience is that package management in a virtual environment with python3 just works."
  },
  {
    "objectID": "cookbook.html#skeletonize-simplification",
    "href": "cookbook.html#skeletonize-simplification",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "3.1 Skeletonize simplification",
    "text": "3.1 Skeletonize simplification\nAs the script take both a filepath or URL, to simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\n$ skeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg\nThe base skeletonize.py also takes parameters to split buffered line segments or preserve knots. These parameters:\n$ skeltonize.py\nstart       0:00:00.000266\nusage: skeletonize.py [-h] [--simplify SIMPLIFY] [--buffer BUFFER] [--scale SCALE] [--knot] [--segment] inpath [outpath]\nskeletonize.py: error: the following arguments are required: inpath"
  },
  {
    "objectID": "cookbook.html#voronoi-simplification",
    "href": "cookbook.html#voronoi-simplification",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "3.2 Voronoi simplification",
    "text": "3.2 Voronoi simplification\nAs the script take a filepath or URL, simplify the rail centre-line track-model near Doncaster to the GeoPKG file sk-doncaster.gpkg:\n$ skeletonize.py https://github.com/anisotropi4/parenx/blob/main/data/rnet_doncaster_rail.geojson?raw=true sk-doncaster.gpkg\nThe base voronoi.py also takes a tolerance parameter6 to sets to the Voronoi polygon overlap:\nstart       0:00:00.000154\nusage: voronoi.py [-h] [--simplify SIMPLIFY] [--scale SCALE] [--buffer BUFFER] [--tolerance TOLERANCE] inpath [outpath]\nvoronoi.py: error: the following arguments are required: inpath"
  },
  {
    "objectID": "cookbook.html#find-the-helper-script",
    "href": "cookbook.html#find-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.1 Find the helper script",
    "text": "4.1 Find the helper script\nTo find it:\n$ find . -name run.sh\n./venv/lib/python3.12/site-packages/parenx/run.sh"
  },
  {
    "objectID": "cookbook.html#copy-the-helper-script",
    "href": "cookbook.html#copy-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.2 Copy the helper script",
    "text": "4.2 Copy the helper script\nCopy the helper script to the working directory. If you want to check for its existence copy it to the working directory type:\n$ ls run.sh\nls: cannot access 'run.sh': No such file or directory\n$ find . -name run.sh -exec cp {} . \\;\n$ ls run.sh\nrun.sh\nOtherwise the following will suffice:\n$ find . -name run.sh -exec cp {} . \\;"
  },
  {
    "objectID": "cookbook.html#run-the-helper-script",
    "href": "cookbook.html#run-the-helper-script",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.3 Run the helper script",
    "text": "4.3 Run the helper script\nThe default runs the skeltonize and voronoi simplification scripts with a number of parameters, against an OpenStreetMap7 Edinburgh Princes Street road network file (net_princes_street.geojson). It creates a GeoPKG8 with three output layers and, if ogr2ogr is installed, GeoJSON9.\n$ ./run.sh\nsimplify ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nskeletonize ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nstart       0:00:00.000270\nread geojson    0:00:00.093758\n...\nwrite simple    0:00:03.403231\nwrite primal    0:00:03.446779\nstop        0:00:03.498828\nvoronoi ./venv/lib/python3.12/site-packages/parenx/data/rnet_princes_street.geojson\nstart       0:00:00.000165\nread geojson    0:00:00.079670\n...\nstop        0:00:19.703512"
  },
  {
    "objectID": "cookbook.html#what-does-the-helper-run.sh-do",
    "href": "cookbook.html#what-does-the-helper-run.sh-do",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "4.4 What does the helper run.sh do?",
    "text": "4.4 What does the helper run.sh do?\nThe helper script creates the enviroment and runs the skeltonize and voronoi simplification scripts with different simplification parameters, and converts the output into a sanitized GeoJSON format if ogr2ogr is installed. The path and output filename can also be specified.\n\n4.4.1 Set up environment\nAs above this checks to see if a venv directory exists, creates and populates it if not, and activates the environment:\n#!/usr/bin/env bash\n\nif [ ! -d venv ]; then\n    python3 -m venv venv\n    source venv/bin/activate\n    pip install --upgrade pip\n    pip install --upgrade wheel\n    pip install parenx\nfi\n\nsource venv/bin/activate\nIt also see if there are any command line parameters set and creates an archive directory, if it is absent:\nLIBPATH=$(find . -name data | fgrep parenx)\nINPATH=${1:-\"${LIBPATH}/rnet_princes_street.geojson\"}\nOUTPUT=${2:-\"output\"}\n\necho simplify ${INPATH}\n\nif [ ! -d archive ]; then\n    mkdir archive\nfi\nThis sets the LIBPATH shell variable to the location of parenx library.\nIt also sets the INPATH and OUTPATH shell variables to command line values, or defaults.\n\n\n4.4.2 Archive previous files\nCreate an archive directory, and archive any existing output files.\nif [ ! -d archive ]; then\n    mkdir archive\nfi\n\nfor k in sk vr\ndo\n    if [ -s ${k}-${OUTPUT}.gpkg ]; then\n        mv ${k}-${OUTPUT}.gpkg archive\n    fi\n    if [ -s ${k}-${OUTPUT}.geojson ]; then\n        mv ${k}-${OUTPUT}.geojson archive\n    fi\ndone\n\n\n4.4.3 Simplify using skeletonization\nThis creates three skeletonization outputs with varying simplify and segment parameters:\necho skeletonize ${INPATH}\nskeletonize.py ${INPATH} sk-${OUTPUT}.gpkg\nskeletonize.py ${INPATH} sk-${OUTPUT}-simple.gpkg --simplify 1.0\nskeletonize.py ${INPATH} sk-${OUTPUT}-segment.gpkg --segment\n\n\n4.4.4 Simplify using Voronoi\nThis creates two Voronoi outputs with varying simplify parameters:\necho voronoi ${INPATH}\nvoronoi.py ${INPATH} vr-${OUTPUT}.gpkg\nvoronoi.py ${INPATH} vr-${OUTPUT}-simple.gpkg --simplify 1.0\n\n\n4.4.5 What does this all look like?\nRemembering less is more:\n$ less run.sh\n#!/usr/bin/env bash\n\nif [ ! -d venv ]; then\n    python3 -m venv venv\n    source venv/bin/activate\n    pip install --upgrade pip\n    pip install --upgrade wheel\n    pip install parenx\nfi\n\nsource venv/bin/activate\n\nLIBPATH=$(find . -name data | fgrep parenx | head -1)\nINPATH=${1:-\"${LIBPATH}/rnet_princes_street.geojson\"}\nOUTPUT=${2:-\"output\"}\n\necho simplify ${INPATH}\n\nif [ ! -d archive ]; then\n    mkdir archive\nfi\n\nfor k in sk vr\ndo\n    if [ -s ${k}-${OUTPUT}.gpkg ]; then\n        mv ${k}-${OUTPUT}.gpkg archive\n    fi\n    if [ -s ${k}-${OUTPUT}.geojson ]; then\n        mv ${k}-${OUTPUT}.geojson archive\n    fi\ndone\n\necho skeletonize ${INPATH}\nskeletonize.py ${INPATH} sk-${OUTPUT}.gpkg\nskeletonize.py ${INPATH} sk-${OUTPUT}-simple.gpkg --simplify 1.0\nskeletonize.py ${INPATH} sk-${OUTPUT}-segment.gpkg --segment\necho voronoi ${INPATH}\nvoronoi.py ${INPATH} vr-${OUTPUT}.gpkg\nvoronoi.py ${INPATH} vr-${OUTPUT}-simple.gpkg --simplify 1.0\n\nOGR2OGR=$(which ogr2ogr)\nif [ x\"${OGR2OGR}\" != x ]; then\n    for k in sk vr\n    do\n        rm -f ${k}-${OUTPUT}.geojson\n        ogr2ogr -f GeoJSON ${k}-${OUTPUT}.geojson ${k}-${OUTPUT}.gpkg line\n        sed -i 's/00000[0-9]*//g' ${k}-${OUTPUT}.geojson\n    done\n    for k in sk vr\n    do\n        rm -f ${k}-${OUTPUT}-simple.geojson\n        ogr2ogr -f GeoJSON ${k}-${OUTPUT}-simple.geojson ${k}-${OUTPUT}-simple.gpkg line\n        sed -i 's/00000[0-9]*//g' ${k}-${OUTPUT}-simple.geojson\n    done\nfi"
  },
  {
    "objectID": "cookbook.html#footnotes",
    "href": "cookbook.html#footnotes",
    "title": "How to use the parenx module scripts to simplify linear network features",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe network merge paper here.↩︎\nSee the online project.↩︎\nThe Debian Linux distribution↩︎\nGitHub data used in development.↩︎\nThe simplify parameter sets shapely simplify function tolerance value.↩︎\nThe tolerance parameter set shapely voronoi_diagram function Voronoi snapping tolerance.↩︎\nThe OpenStreetMap map of Edinburgh.↩︎\nThe OSC GeoPKG specification.↩︎\nThe GeoJSON Specification (RFC 7946).↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "networkmerge",
    "section": "",
    "text": "This website hosts the networkmerge paper which presents methods for simplifying route networks for transport planning. The methods were developed for the Network Planning Tool for Scotland which is publicly available at https://npt.scot.\n\nIt was produced with Quarto, which was also used to support the academic paper shown below. See https://quarto.org/docs/websites for further information.\nThe paper is re-built automatically when the source code is updated:\n\n\n\nQuarto Publish\n\n\nSee github.com/nptscot/networkmerge for the source code underlying this website."
  },
  {
    "objectID": "slides.html#references",
    "href": "slides.html#references",
    "title": "Reproducible methods for network simplification",
    "section": "",
    "text": "References\n\n\n\n\n\n\n\n\nMorgan, Malcolm, and Robin Lovelace. 2020. “Travel Flow Aggregation: Nationally Scalable Methods for Interactive and Online Visualisation of Transport Behaviour at the Road Network Level.” Environment & Planning B: Planning & Design, July. https://doi.org/10.1177/2399808320942779."
  }
]